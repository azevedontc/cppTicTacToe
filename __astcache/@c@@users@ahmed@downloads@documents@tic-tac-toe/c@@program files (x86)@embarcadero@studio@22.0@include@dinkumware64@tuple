// tuple standard header
#ifndef _TUPLE_
#define _TUPLE_
#include <type_traits>
#include <xutility>
#include <new>

 #if _IS_GHS

 #if defined(__GHS_PRAGMAS)
  #pragma ghs start_cxx_lib_header
  #pragma ghs startdata
 #endif /* defined(__GHS_PRAGMAS) */

 #if defined(__ghs_max_pack_value)
  #pragma pack (push, __ghs_max_pack_value)
 #endif /* defined(__ghs_max_pack_value) */

#endif /* _IS_GHS */

_STD_BEGIN
	// STRUCT _Ignore
struct _Ignore
	{	// struct that ignores assignments
	template<class _Ty>
		_CONST_FUN_17 void operator=(const _Ty&) const
		{	// do nothing
		}
	};

_CONST_DATA _Ignore ignore = _Ignore();

		// STRUCT _Tuple_alloc_t
struct _Tuple_alloc_t
	{	// tag type to disambiguate added allocator argument
	};

_CONST_DATA _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	// TEMPLATE CLASS _Tuple_val
template<class _Ty>
	struct _Tuple_val
	{	// stores each value in a tuple
	_CONST_FUN _Tuple_val()
		: _Val()
		{	// default construct
		}

	template<class _Other>
		_CONST_FUN _Tuple_val(const _Other& _Arg)
		: _Val(_Arg)
		{	/* construct by copying argument */
		}

	template<class _Other>
		_CONST_FUN _Tuple_val(_Other&& _Arg)
		: _Val(_STD forward<_Other>(_Arg))
		{	// construct by moving argument
		}

	template<class _Other>
		_Tuple_val& operator=(const _Other& _Arg)
		{	// assign by copying object
		_Val = _Arg;
		return (*this);
		}

	template<class _Other>
		_Tuple_val& operator=(_Other&& _Arg)
		{	// assign by moving object
		_Val = _STD forward<_Other>(_Arg);
		return (*this);
		}

	template<class _Alloc,
		class... _Other>
		_Tuple_val(const _Alloc&,
			enable_if_t<!uses_allocator<_Ty, _Alloc>::value,
				_Tuple_alloc_t>, _Other&&... _Arg)
		: _Val(_STD forward<_Other>(_Arg)...)
		{	// construct with optional arguments, no allocator
		}

	template<class _Alloc,
		class... _Other>
		_Tuple_val(const _Alloc& _Al,
			enable_if_t<uses_allocator<_Ty, _Alloc>::value
				&& is_constructible<_Ty,
					allocator_arg_t, _Alloc, _Other...>::value,
				_Tuple_alloc_t>, _Other&&... _Arg)
		: _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...)
		{	// construct with optional arguments, leading allocator
		}

	template<class _Alloc,
		class... _Other>
		_Tuple_val(const _Alloc& _Al,
			enable_if_t<uses_allocator<_Ty, _Alloc>::value
				&& !is_constructible<_Ty,
					allocator_arg_t, _Alloc, _Other...>::value,
				_Tuple_alloc_t>, _Other&&... _Arg)
		: _Val(_STD forward<_Other>(_Arg)..., _Al)
		{	// construct with optional arguments, trailing allocator
		}

	_Ty _Val;
	};

	// CLASS tuple
template<class... _Types>
	class tuple;

template<>
	class tuple<>
	{	// empty tuple
public:
	typedef tuple<> _Myt;
	typedef _Myt _This_type;

	_CONST_FUN tuple() _NOEXCEPT
		{	// default construct
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT
		{	// default construct, allocator
		}

	_CONST_FUN tuple(const tuple&) _NOEXCEPT
		{	// copy construct
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc&, const _Myt&) _NOEXCEPT
		{	// copy construct, allocator
		}

	void swap(_Myt&) _NOEXCEPT
		{	// swap elements
		}

	_CONST_FUN bool _Equals(const _Myt&) const _NOEXCEPT
		{	// test if *this == _Right
		return (true);
		}

	_CONST_FUN bool _Less(const _Myt&) const _NOEXCEPT
		{	// test if *this < _Right
		return (false);
		}
	};

struct _One_arg_t
	{	// tag type to disambiguate construction
	};

// template<class _This,
// 	class... _Rest>
// 	class tuple<_This, _Rest...>
// 		: public tuple<_Rest...>
// 	{	// recursive tuple definition
// public:
// 	typedef _This _This_type;
// 	typedef tuple<_This, _Rest...> _Myt;
// 	typedef tuple<_Rest...> _Mybase;
// 	static const size_t _Mysize = 1 + sizeof...(_Rest);

	// SUPPORT TEMPLATES
	template <bool, class>
		struct _Negate_if;
	template <class _Ty>
		struct _Negate_if<false, _Ty>
			: integral_constant<bool, _Ty::value>
		{	// holds _Ty::value
		};
	template <class _Ty>
		struct _Negate_if<true, _Ty>
			: integral_constant<bool, !_Ty::value>
		{	// negates _Ty::value
		};

	template <bool _B>
		struct _Is_explicit
			: integral_constant<bool, _B>
		{	// template type to indicate whether constructor should be explicit
		};

	template<class...>
		struct _All_default_constructible;

	template<>
		struct _All_default_constructible<tuple<> >
			: true_type
		{	// empty tuple is default constructible
		};
	template<class _Myty,
		class... _Myrest>
		struct _All_default_constructible<tuple<_Myty, _Myrest...> >
			: integral_constant<bool, is_default_constructible<_Myty>::value
				&& _All_default_constructible<tuple<_Myrest...> >::value>
		{	// all types must be default constructible
		};

	template<class...>
		struct _All_implicitly_default_constructible;

	template<>
		struct _All_implicitly_default_constructible<tuple<> >
			: true_type
		{	// empty tuple is implicitly default constructible
		};
	template<class _Myty,
		class... _Myrest>
		struct _All_implicitly_default_constructible<
			tuple<_Myty, _Myrest...> >
			: integral_constant<bool, is_default_constructible<_Myty>::value
				&& _All_implicitly_default_constructible<
					tuple<_Myrest...> >::value>
		{	// all types must be implicitly default constructible
		};

	template <class _Explicit, class...>
		struct _Is_default_constructible;

	template <class _Explicit>
		struct _Is_default_constructible<_Explicit, tuple<> >
			: true_type
		{	// empty tuple is default constructible
		};
	template <class _Explicit,
		class _Myty,
		class... _Myrest>
		struct _Is_default_constructible<
			_Explicit,
			tuple<_Myty, _Myrest...> >
			: integral_constant<bool,
				_All_default_constructible<tuple<_Myty, _Myrest...> >::value
				&& _Negate_if<_Explicit::value,
					_All_implicitly_default_constructible<
					tuple<_Myty,
					_Myrest...> > >::value>
		{	// all types must be default constructible
		};

	template<class...>
		struct _All_copy_constructible
			: true_type
		{	// empty tuple is copy constructible
		};
	template<class _Myty,
		class... _Myrest>
		struct _All_copy_constructible<tuple<_Myty, _Myrest...> >
			: integral_constant<bool,
					is_copy_constructible<_Myty>::value
				&& _All_copy_constructible<tuple<_Myrest...> >::value>
		{	// all types must be copy constructible
		};

	template<class...>
		struct _All_move_constructible
			: true_type
		{	// empty tuple is move constructible
		};
	template<class _Myty,
		class... _Myrest>
		struct _All_move_constructible<tuple<_Myty, _Myrest...> >
			: integral_constant<bool,
					is_move_constructible<_Myty>::value
				&& _All_move_constructible<tuple<_Myrest...> >::value>
		{	// all types must be move constructible
		};

	template <class...>
		struct _All_convertible;

	template <>
		struct _All_convertible<tuple<>, tuple<> >
			: true_type
		{	// empty argument lists always convertible
		};
	template <class _Arg0, class... _Arg>
		struct _All_convertible<tuple<_Arg0, _Arg...>, tuple<> >
			: false_type
		{	// non-empty argument list not convertible from empty list
		};
	template <class _Arg0, class... _Arg>
		struct _All_convertible<tuple<>, tuple<_Arg0, _Arg...> >
			: false_type
		{	// empty argument list not convertible from non-empty list
		};
	template <class _Src, class... _Src_rest,
		class _Dst, class... _Dst_rest>
		struct _All_convertible<tuple<_Src, _Src_rest...>,
			tuple<_Dst, _Dst_rest...> >
			: integral_constant<bool,
					is_convertible<_Src, _Dst>::value
				&& _All_convertible<tuple<_Src_rest...>,
					tuple<_Dst_rest...> >::value>
		{	// all types must be convertible
		};

	template <class _Explicit, class...>
		struct _Is_copy_constructible;

	template <class _Explicit>
		struct _Is_copy_constructible<_Explicit, tuple<> >
			: true_type
		{	// empty tuple is default constructible
		};
	template <class _Explicit,
			class _Myty,
			class... _Myrest>
		struct _Is_copy_constructible<
			_Explicit,
			tuple<_Myty, _Myrest...> >
			: integral_constant<bool,
				_All_copy_constructible<_Myty, _Myrest...>::value
				&& _Negate_if<_Explicit::value,
					_All_convertible<tuple<const _Myty&, const _Myrest&...>,
						tuple<_Myty, _Myrest...> > >::value>
		{	// all types must be copy constructible
		};

	template <class...>
		struct _All_constructible;

	template <>
		struct _All_constructible<tuple<>, tuple<> >
			: true_type
		{	// empty argument list always constructible
		};
	template <class _Arg0, class... _Args>
		struct _All_constructible<tuple<_Arg0, _Args...>, tuple<> >
			: false_type
		{	// non-empty argument list not constructible from empty list
		};
	template <class _Arg0, class... _Args>
		struct _All_constructible<tuple<>, tuple<_Arg0, _Args...> >
			: false_type
		{	// empty argument list not constructible from non-empty list
		};
	template <class _Src, class... _Src_rest,
		class _Dst, class... _Dst_rest>
		struct _All_constructible<tuple<_Src, _Src_rest...>,
			tuple<_Dst, _Dst_rest...> >
			: integral_constant<bool,
					is_constructible<_Src, _Dst>::value
				&& _All_constructible<tuple<_Src_rest...>,
					tuple<_Dst_rest...> >::value>
		{	// all types must be constructible
		};

	template <class _Explicit, class...>
		struct _Is_lvalue_constructible;

	template <class _Explicit>
		struct _Is_lvalue_constructible<_Explicit, tuple<> >
			: true_type
		{	// empty tuple is constructible from lvalue
		};
	template <class _Explicit,
			class _Myty,
			class... _Myrest,
			class _This,
			class... _Rest>
		struct _Is_lvalue_constructible<
			_Explicit,
			tuple<_Myty, _Myrest...>,
			tuple<_This, _Rest...> >
			: integral_constant<bool,
				sizeof...(_Rest) == sizeof...(_Myrest)
				&& _All_constructible<tuple<_This, _Rest...>,
					tuple<const _Myty&, const _Myrest&...> >::value
				&& _Negate_if<_Explicit::value,
					_All_convertible<tuple<const _Myty&, const _Myrest&...>,
						tuple<_This, _Rest...> > >::value>
		{	// all types must be constructible from lvalue
		};

	template <class _Explicit, class...>
		struct _Is_rvalue_constructible;

	template <class _Explicit>
		struct _Is_rvalue_constructible<_Explicit, tuple<> >
			: true_type
		{	// empty tuple is constructible from rvalue
		};
	template <class _Explicit,
			class _Myty,
			class... _Myrest,
			class _This,
			class... _Rest>
		struct _Is_rvalue_constructible<
			_Explicit,
			tuple<_Myty, _Myrest...>,
			tuple<_This, _Rest...> >
			: integral_constant<bool,
				sizeof...(_Rest) == sizeof...(_Myrest)
				&& _All_constructible<tuple<_This, _Rest...>,
					tuple<_Myty&&, _Myrest&&...> >::value
				&& _Negate_if<_Explicit::value,
					_All_convertible<tuple<_Myty&&, _Myrest&&...>,
						tuple<_This, _Rest...> > >::value>
		{	// all types must be constructible from rvalue
		};

template<class _This,
	class... _Rest>
	class tuple<_This, _Rest...>
		: public tuple<_Rest...>
	{	// recursive tuple definition
public:
	typedef _This _This_type;
	typedef tuple<_This, _Rest...> _Myt;
	typedef tuple<_Rest...> _Mybase;
	static const size_t _Mysize = 1 + sizeof...(_Rest);

	// tuple CONSTRUCTORS
	template <class _Mythis = _This,
		typename enable_if<_All_default_constructible<
				tuple<_Mythis, _Rest...> >::value,
			bool>::type = true>
		_CONST_FUN tuple()
			: _Mybase(),
				_Myfirst()
		{	// default construct
		}

	template <class _Mythis = _This,
		typename enable_if<_Is_copy_constructible<
				_Is_explicit<false>,
				tuple<_Mythis, _Rest...>,
				_Myt>::value,
			bool>::type = true>
		_CONST_FUN tuple(const _This& _This_arg,
			const _Rest&... _Rest_arg)
			: _Mybase(_Rest_arg...),
				_Myfirst(_This_arg)
		{	// construct from elements
		}
	template <class _Mythis = _This,
		typename enable_if<_Is_copy_constructible<
				_Is_explicit<true>,
				tuple<_Mythis, _Rest...>,
				_Myt>::value,
			bool>::type = true>
		explicit _CONST_FUN tuple(const _This& _This_arg,
			const _Rest&... _Rest_arg)
			: _Mybase(_Rest_arg...),
				_Myfirst(_This_arg)
		{	// explicit construct from elements
		}

	template <class _Other0,
		class... _Other,
		typename enable_if<_Is_rvalue_constructible<
				_Is_explicit<false>,
				tuple<_Other0, _Other...>,
				_Myt>::value,
			bool>::type = true>
		_CONST_FUN tuple(_Other0&& _First_arg,
			_Other&&... _Other_arg)
			: _Mybase(_STD forward<_Other>(_Other_arg)...),
				_Myfirst(_STD forward<_Other0>(_First_arg))
		{	// move construct from values
		}
	template <class _Other0,
		class... _Other,
		typename enable_if<_Is_rvalue_constructible<
				_Is_explicit<true>,
				tuple<_Other0, _Other...>,
				_Myt>::value,
			bool>::type = true>
		explicit _CONST_FUN tuple(_Other0&& _First_arg,
			_Other&&... _Other_arg)
			: _Mybase(_STD forward<_Other>(_Other_arg)...),
				_Myfirst(_STD forward<_Other0>(_First_arg))
		{	// move construct from values
		}

	tuple(const _Myt&) = default;	// ONLY IF _All_copy_constructible<_Myt>
	tuple(_Myt&&) = default;	// ONLY IF _All_move_constructible<_Myt>

	template <class _Other0,
		class... _Other,
		typename enable_if<_Is_lvalue_constructible<
				_Is_explicit<false>,
				tuple<_Other0, _Other...>,
				_Myt>::value
			&& (_Mysize != 1 // sizeof...(_Types) != 1
				|| (!is_convertible<const tuple<_Other0>&, _This>::value
					&& !is_constructible<_This, const tuple<_Other0>&>::value
					&& !is_same<_This, _Other0>::value)),
			bool>::type = true>
		_CONST_FUN tuple(const tuple<_Other0, _Other...>& _Right)
			: _Mybase((const tuple<_Other...>&)_Right),
				_Myfirst(_STD forward<_This>
					(_Right._Myfirst._Val))
		{	// construct by copying same size tuple
		}
	template <class _Other0,
		class... _Other,
		typename enable_if<_Is_lvalue_constructible<
				_Is_explicit<true>,
				tuple<_Other0, _Other...>,
				_Myt>::value
			&& (_Mysize != 1 // sizeof...(_Types) != 1
				|| (!is_convertible<const tuple<_Other0>&, _This>::value
					&& !is_constructible<_This, const tuple<_Other0>&>::value
					&& !is_same<_This, _Other0>::value)),
			bool>::type = true>
		explicit _CONST_FUN tuple(const tuple<_Other0, _Other...>& _Right)
			: _Mybase((const tuple<_Other...>&)_Right),
				_Myfirst(_STD forward<_This>
					(_Right._Myfirst._Val))
		{	// construct by copying same size tuple
		}

	template <class _Other0,
		class... _Other,
		typename enable_if<_Is_rvalue_constructible<
				_Is_explicit<false>,
				tuple<_Other0, _Other...>,
				_Myt>::value
			&& (_Mysize != 1 // sizeof...(_Types) != 1
				|| (!is_convertible<tuple<_Other0>, _This>::value
					&& !is_constructible<_This, tuple<_Other0>>::value
					&& !is_same<_This, _Other0>::value)),
			bool>::type = true>
		_CONST_FUN tuple(tuple<_Other0, _Other...>&& _Right)
			: _Mybase((typename tuple<_Other0, _Other...>::_Mybase&&)_Right),
				_Myfirst(_STD forward<_Other0>
					(_Right._Myfirst._Val))
		{	// construct by moving same size tuple
		}
	template <class _Other0,
		class... _Other,
		typename enable_if<_Is_rvalue_constructible<
				_Is_explicit<true>,
				tuple<_Other0, _Other...>,
				_Myt>::value
			&& (_Mysize != 1 // sizeof...(_Types) != 1
				|| (!is_convertible<tuple<_Other0>, _This>::value
					&& !is_constructible<_This, tuple<_Other0>>::value
					&& !is_same<_This, _Other0>::value)),
			bool>::type = true>
		explicit _CONST_FUN tuple(tuple<_Other0, _Other...>&& _Right)
			: _Mybase((typename tuple<_Other0, _Other...>::_Mybase&&)_Right),
				_Myfirst(_STD forward<_Other0>
					(_Right._Myfirst._Val))
		{	// construct by moving same size tuple
		}

	template <class _First,
		class _Second,
		typename enable_if<_Is_lvalue_constructible<
				_Is_explicit<false>,
				tuple<_First, _Second>,
				_Myt>::value
			&& _Mysize == 2, // sizeof...(_Types) == 2
			bool>::type = true>
		_CONST_FUN tuple(const pair<_First, _Second>& _Right)
		: _Mybase(_One_arg_t(), _Right.second),
			_Myfirst(_Right.first)
		{	// construct by copying pair
		}
	template <class _First,
		class _Second,
		typename enable_if<_Is_lvalue_constructible<
				_Is_explicit<true>,
				tuple<_First, _Second>,
				_Myt>::value
			&& _Mysize == 2, // sizeof...(_Types) == 2
			bool>::type = true>
		explicit _CONST_FUN tuple(const pair<_First, _Second>& _Right)
		: _Mybase(_One_arg_t(), _Right.second),
			_Myfirst(_Right.first)
		{	// construct by copying pair
		}

	template <class _First,
		class _Second,
		typename enable_if<_Is_rvalue_constructible<
				_Is_explicit<false>,
				tuple<_First, _Second>,
				_Myt>::value
			&& _Mysize == 2, // sizeof...(_Types) == 2
			bool>::type = true>
		_CONST_FUN tuple(pair<_First, _Second>&& _Right)
		: _Mybase(_One_arg_t(), _STD forward<_Second>(_Right.second)),
			_Myfirst(_STD forward<_First>(_Right.first))
		{	// construct by moving pair
		}
	template <class _First,
		class _Second,
		typename enable_if<_Is_rvalue_constructible<
				_Is_explicit<true>,
				tuple<_First, _Second>,
				_Myt>::value
			&& _Mysize == 2, // sizeof...(_Types) == 2
			bool>::type = true>
		explicit _CONST_FUN tuple(pair<_First, _Second>&& _Right)
		: _Mybase(_One_arg_t(), _STD forward<_Second>(_Right.second)),
			_Myfirst(_STD forward<_First>(_Right.first))
		{	// construct by moving pair
		}

	template <class _Alloc,
		class _Mythis = _This,
		typename enable_if<_All_default_constructible<
				tuple<_Mythis, _Rest...> >::value,
			bool>::type = true>
		tuple(allocator_arg_t, const _Alloc& _Al)
		: _Mybase(allocator_arg, _Al),
			_Myfirst(_Al, _Tuple_alloc)
		{	// construct default, allocator
		}

	template <class _Alloc,
		class _Mythis = _This,
		typename enable_if<_Is_copy_constructible<
				_Is_explicit<false>,
				tuple<_Mythis, _Rest...> >::value,
			bool>::type = true>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const _This& _This_arg, const _Rest&... _Rest_arg)
		: _Mybase(allocator_arg, _Al, _Rest_arg...),
			_Myfirst(_Al, _Tuple_alloc, _This_arg)
		{	// construct from one or more copied elements, allocator
		}
	template <class _Alloc,
		class _Mythis = _This,
		typename enable_if<_Is_copy_constructible<
				_Is_explicit<true>,
				tuple<_Mythis, _Rest...> >::value,
			bool>::type = true>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			const _This& _This_arg, const _Rest&... _Rest_arg)
		: _Mybase(allocator_arg, _Al, _Rest_arg...),
			_Myfirst(_Al, _Tuple_alloc, _This_arg)
		{	// construct from one or more copied elements, allocator
		}

	template <class _Alloc,
		class _Other0,
		class... _Other,
		typename enable_if<_Is_rvalue_constructible<
				_Is_explicit<false>,
				tuple<_Other0, _Other...>,
				_Myt>::value,
			bool>::type = true>
		tuple(allocator_arg_t, const _Alloc& _Al, _Other0&& _Other_arg,
			_Other&&... _Other_args)
		: _Mybase(allocator_arg, _Al,
				_STD forward<_Other>(_Other_arg)...),
			_Myfirst(_Al, _Tuple_alloc,
				_STD forward<_Other0>(_Other_arg))
		{	// construct from one or more moved values, allocator
		}
	template <class _Alloc,
		class _Other0,
		class... _Other,
		typename enable_if<_Is_rvalue_constructible<
				_Is_explicit<true>,
				tuple<_Other0, _Other...>,
				_Myt>::value,
			bool>::type = true>
		explicit tuple(allocator_arg_t, const _Alloc& _Al, _Other0&& _Other_arg,
			_Other&&... _Other_args)
		: _Mybase(allocator_arg, _Al,
				_STD forward<_Other>(_Other_arg)...),
			_Myfirst(_Al, _Tuple_alloc,
				_STD forward<_Other0>(_Other_arg))
		{	// construct from one or more moved values, allocator
		}

#if defined(__CODEGEARC__)
	template <class _Alloc, class _UMyt = _Myt,
		typename enable_if<_All_copy_constructible<_UMyt>::value,
#else
	template <class _Alloc,
		typename enable_if<_All_copy_constructible<_Myt>::value,
#endif
			bool>::type = true>
		tuple(allocator_arg_t, const _Alloc& _Al, const tuple& _Right)
		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
			_Myfirst(_Al, _Tuple_alloc,
				_Right._Myfirst._Val)
		{	// construct by copying, allocator
		}

	template <class _Alloc,
		class _Other0,
		class... _Other,
		typename enable_if<_Is_lvalue_constructible<
				_Is_explicit<false>,
				tuple<_Other0, _Other...>,
				_Myt>::value
			&& (_Mysize != 1 // sizeof...(_Types) != 1
				|| (!is_convertible<const tuple<_Other0>&, _This>::value
					&& !is_constructible<_This, const tuple<_Other0>&>::value
					&& !is_same<_This, _Other0>::value)),
			bool>::type = true>
		tuple(allocator_arg_t, const _Alloc& _Al, const tuple<_Other0, _Other...>& _Right)
		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
			_Myfirst(_Al, _Tuple_alloc,
				_Right._Myfirst._Val)
		{	// construct by copying same size tuple, allocator
		}
	template <class _Alloc,
		class _Other0,
		class... _Other,
		typename enable_if<_Is_lvalue_constructible<
				_Is_explicit<true>,
				tuple<_Other0, _Other...>,
				_Myt>::value
			&& (_Mysize != 1 // sizeof...(_Types) != 1
				|| (!is_convertible<const tuple<_Other0>&, _This>::value
					&& !is_constructible<_This, const tuple<_Other0>&>::value
					&& !is_same<_This, _Other0>::value)),
			bool>::type = true>
		explicit tuple(allocator_arg_t, const _Alloc& _Al, const tuple<_Other0, _Other...>& _Right)
		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
			_Myfirst(_Al, _Tuple_alloc,
				_Right._Myfirst._Val)
		{	// construct by copying same size tuple, allocator
		}

	template <class _Alloc,
		class _Other0,
		class... _Other,
		typename enable_if<_Is_rvalue_constructible<
				_Is_explicit<false>,
				tuple<_Other0, _Other...>,
				_Myt>::value
			&& (_Mysize != 1 // sizeof...(_Types) != 1
				|| (!is_convertible<tuple<_Other0>, _This>::value
					&& !is_constructible<_This, tuple<_Other0>>::value
					&& !is_same<_This, _Other0>::value)),
			bool>::type = true>
		tuple(allocator_arg_t, const _Alloc& _Al, tuple<_Other0, _Other...>&& _Right)
		: _Mybase(allocator_arg, _Al, _STD forward<tuple<_Other...> >(_Right)),
			_Myfirst(_Al, _Tuple_alloc, _STD forward<_Other0>(_Right._Myfirst._Val))
		{	// construct by moving same size tuple, allocator
		}
	template <class _Alloc,
		class _Other0,
		class... _Other,
		typename enable_if<_Is_rvalue_constructible<
				_Is_explicit<true>,
				tuple<_Other0, _Other...>,
				_Myt>::value
			&& (_Mysize != 1 // sizeof...(_Types) != 1
				|| (!is_convertible<tuple<_Other0>, _This>::value
					&& !is_constructible<_This, tuple<_Other0>>::value
					&& !is_same<_This, _Other0>::value)),
			bool>::type = true>
		explicit tuple(allocator_arg_t, const _Alloc& _Al, tuple<_Other0, _Other...>&& _Right)
		: _Mybase(allocator_arg, _Al, _STD forward<tuple<_Other...> >(_Right)),
			_Myfirst(_Al, _Tuple_alloc, _STD forward<_Other0>(_Right._Myfirst._Val))
		{	// construct by moving same size tuple, allocator
		}

	template <class _Alloc,
		class _First,
		class _Second,
		typename enable_if<_Is_lvalue_constructible<
				_Is_explicit<false>,
				tuple<_First, _Second>,
				_Myt>::value
			&& _Mysize == 2, // sizeof...(_Types) == 2
			bool>::type = true>
		tuple(allocator_arg_t, const _Alloc& _Al, const pair<_First, _Second>& _Right)
		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
			_Myfirst(_Al, _Tuple_alloc,
				_Right.first)
		{	// construct by copying pair, allocator
		}
	template <class _Alloc,
		class _First,
		class _Second,
		typename enable_if<_Is_lvalue_constructible<
				_Is_explicit<true>,
				tuple<_First, _Second>,
				_Myt>::value
			&& _Mysize == 2, // sizeof...(_Types) == 2
			bool>::type = true>
		explicit tuple(allocator_arg_t, const _Alloc& _Al, const pair<_First, _Second>& _Right)
		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
			_Myfirst(_Al, _Tuple_alloc,
				_Right.first)
		{	// construct by copying pair, allocator
		}

	template <class _Alloc,
		class _First,
		class _Second,
		typename enable_if<_Is_rvalue_constructible<
				_Is_explicit<false>,
				tuple<_First, _Second>,
				_Myt>::value
			&& _Mysize == 2, // sizeof...(_Types) == 2
			bool>::type = true>
		tuple(allocator_arg_t, const _Alloc& _Al, pair<_First, _Second>&& _Right)
		: _Mybase(_One_arg_t(), _STD forward<_Second>(_Right.second)),
			_Myfirst(_STD forward<_First>(_Right.first))
		{	// construct by moving pair
		}
	template <class _Alloc,
		class _First,
		class _Second,
		typename enable_if<_Is_rvalue_constructible<
				_Is_explicit<true>,
				tuple<_First, _Second>,
				_Myt>::value
			&& _Mysize == 2, // sizeof...(_Types) == 2
			bool>::type = true>
		explicit tuple(allocator_arg_t, const _Alloc& _Al, pair<_First, _Second>&& _Right)
		: _Mybase(_One_arg_t(), _STD forward<_Second>(_Right.second)),
			_Myfirst(_STD forward<_First>(_Right.first))
		{	// construct by moving pair
		}

	// tuple ASSIGNMENTS
	template<template<class, class> class _Is_fn,
		class _Tuple1,
		class _Tuple2>
		struct _Is_tuple_assignable;

	template<template<class, class> class _Is_fn,
		class _First0,
		class _First1>
		struct _Is_tuple_assignable<_Is_fn, tuple<_First0>, tuple<_First1> >
		{	// test for assignable first element
		static const bool value = _Is_fn<_First0&, _First1&>::value;
		};

	template<template<class, class> class _Is_fn,
		class _First0,
		class... _Rest0,
		class _First1,
		class... _Rest1>
		struct _Is_tuple_assignable<_Is_fn, tuple<_First0, _Rest0...>,
			tuple<_First1, _Rest1...> >
		{	// test for assignable elements
		static const bool value =
			_Is_fn<_First0&, _First1&>::value
				&& _Is_tuple_assignable<_Is_fn,
					tuple<_Rest0...>,
					tuple<_Rest1...> >::value;
		};

	template<class _Ty1,
		class _Ty2>
		struct _Is_copy_assignable
			: public is_assignable<_Ty1&, const _Ty2&>
		{	// tests for copy assignable
		};

	template<class _Other0,
		class... _Other,
		class = enable_if_t<_Mysize == 1 + sizeof...(_Other)
			&& _Is_tuple_assignable<_Is_copy_assignable,
				_Myt, tuple<_Other0, _Other...> >::value,
			void> >
		_Myt& operator=(const tuple<_Other0, _Other...>& _Right)
		{	// assign by copying same size tuple
		_Myfirst._Val = _Right._Myfirst._Val;
		_Get_rest() = _Right._Get_rest();
		return (*this);
		}

	template<class _Ty1,
		class _Ty2>
		struct _Is_move_assignable
			: public is_assignable<_Ty1&, _Ty2&&>
		{	// tests for copy assignable
		};

	template<class _Other0,
		class... _Other,
		class = enable_if_t<_Mysize == 1 + sizeof...(_Other)
			&& _Is_tuple_assignable<_Is_move_assignable,
				_Myt, tuple<_Other0, _Other...> >::value,
			void> >
		_Myt& operator=(tuple<_Other0, _Other...>&& _Right)
		{	// assign by moving same size tuple
		_Myfirst._Val = _STD forward<typename tuple<_Other0, _Other...>
			::_This_type>(_Right._Myfirst._Val);
		_Get_rest() = _STD forward<typename tuple<_Other0, _Other...>
			::_Mybase>(_Right._Get_rest());
		return (*this);
		}

	template<class... _Other>
		_CONST_FUN bool _Equals(const tuple<_Other...>& _Right) const
		{	// test if *this == _Right
		_STATIC_ASSERT2(_Mysize == sizeof...(_Other),
			"comparing tuple to object with different size");
		return (_Myfirst._Val == _Right._Myfirst._Val
			&& _Mybase::_Equals(_Right._Get_rest()));
		}

	template<class... _Other>
		_CONST_FUN bool _Less(const tuple<_Other...>& _Right) const
		{	// test if *this < _Right
		_STATIC_ASSERT2(_Mysize == sizeof...(_Other),
			"comparing tuple to object with different size");
		return (_Myfirst._Val < _Right._Myfirst._Val
			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
				&& _Mybase::_Less(_Right._Get_rest())));
		}

	template<class _Tag,
		class _This2,
		class = enable_if_t<is_same<_Tag, _One_arg_t>::value,
			void> >
		_CONST_FUN tuple(_Tag, _This2&& _This_arg)
		: _Mybase(),
			_Myfirst(_STD forward<_This2>(_This_arg))
		{	// construct from one perfectly forwarded element
		}

	_Myt& operator=(const _Myt& _Right)
		{	// assign
		_Myfirst._Val = _Right._Myfirst._Val;
		_Get_rest() = _Right._Get_rest();
		return (*this);
		}

	template<class _First,
		class _Second>
		_Myt& operator=(const pair<_First, _Second>& _Right)
		{	// assign by copying pair
		_STATIC_ASSERT2(_Mysize == 2,
			"assigning to tuple from object with different size");
		_Myfirst._Val = _Right.first;
		_Get_rest()._Myfirst._Val = _Right.second;
		return (*this);
		}

	_Myt& operator=(_Myt&& _Right)
		_NOEXCEPT_OP(is_nothrow_move_assignable<_This>::value
			&& is_nothrow_move_assignable<_Mybase>::value)
		{	// assign by moving
		_Myfirst._Val = _STD forward<_This>(_Right._Myfirst._Val);
		_Get_rest() = _STD forward<_Mybase>(_Right._Get_rest());
		return (*this);
		}

	template<class _First,
		class _Second>
		_Myt& operator=(pair<_First, _Second>&& _Right)
		{	// assign by moving pair
		_STATIC_ASSERT2(_Mysize == 2,
			"assigning to tuple from object with different size");
		_Myfirst._Val = _STD forward<_First>(_Right.first);
		_Get_rest()._Myfirst._Val = _STD forward<_Second>(_Right.second);
		return (*this);
		}

	_Mybase& _Get_rest() _NOEXCEPT
		{	// get reference to rest of elements
		return (*this);
		}

	_CONST_FUN const _Mybase& _Get_rest() const _NOEXCEPT
		{	// get const reference to rest of elements
		return (*this);
		}

	void swap(tuple& _Right)
		_NOEXCEPT_OP(
			_NOEXCEPT_OP(_Swap_adl(_Right._Myfirst._Val,
				_Right._Myfirst._Val))
			&& _NOEXCEPT_OP(_Swap_adl(_Right._Get_rest(),
				_Right._Get_rest())))
		{	// swap *this and _Right
		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
		_Mybase::swap(_Right._Get_rest());
		}

	_Tuple_val<_This> _Myfirst;	// the stored element
	};

	// OPERATORS FOR tuple
template<class... _Types1,
	class... _Types2> inline
	_CONST_FUN bool operator==(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	// test if _Left == _Right
	return (_Left._Equals(_Right));
	}

template<class... _Types1,
	class... _Types2> inline
	_CONST_FUN bool operator!=(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	// test if _Left != _Right
	return (!(_Left == _Right));
	}

template<class... _Types1,
	class... _Types2> inline
	_CONST_FUN bool operator<(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	// test if _Left < _Right
	return (_Left._Less(_Right));
	}

template<class... _Types1,
	class... _Types2> inline
	_CONST_FUN bool operator>=(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	// test if _Left >= _Right
	return (!(_Left < _Right));
	}

template<class... _Types1,
	class... _Types2> inline
	_CONST_FUN bool operator>(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	// test if _Left > _Right
	return (_Right < _Left);
	}

template<class... _Types1,
	class... _Types2> inline
	_CONST_FUN bool operator<=(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	// test if _Left <= _Right
	return (!(_Right < _Left));
	}

 #if _HAS_CPP17
template<class... _Types>
	struct _Tuple_is_swappable
		: true_type
	{	// empty tuple is swappable
	};

template<class _This,
	class... _Rest>
	struct _Tuple_is_swappable<_This, _Rest...>
		: _Cat_base<is_swappable<_This>::value
			&& _Tuple_is_swappable<_Rest...>::value>
	{	// test first element
	};

template<class... _Types,
	class = enable_if_t<_Tuple_is_swappable<_Types...>::value,
		void> > inline

 #else /* _HAS_CPP17 */
template<class... _Types> inline
 #endif /* _HAS_CPP17 */

	void swap(tuple<_Types...>& _Left,
		tuple<_Types...>& _Right)
			_NOEXCEPT_OP(_NOEXCEPT_OP(_Left.swap(_Right)))
	{	// swap _Left and _Right
	return (_Left.swap(_Right));
	}

	// CLASS _Tuple_element (find element by type)
template<class _Ty,
	class _Tuple>
	struct _Tuple_element;

template<class _This,
	class... _Rest>
	struct _Tuple_element<_This, tuple<_This, _Rest...> >
	{	// select first element
	typedef int _Check_type;
	_STATIC_ASSERT2((is_void<typename _Tuple_element<_This,
		tuple<_Rest...> >::_Check_type>::value),
		"duplicate type T in get<T>(tuple)");

	typedef _This type;
	typedef tuple<_This, _Rest...> _Ttype;
	};

template<class _Ty,
	class _This,
	class... _Rest>
	struct _Tuple_element<_Ty, tuple<_This, _Rest...> >
		: public _Tuple_element<_Ty, tuple<_Rest...> >
	{	// recursive _Tuple_element definition
	};

template<class _Ty>
	struct _Tuple_element<_Ty, tuple<> >
	{	// backstop _Tuple_element definition
	typedef void _Check_type;	// proof that no duplicate type exists
	};

template<class _Ty,
	class _Tuple>
	struct _Tuple_element<_Ty, const _Tuple>
		: public _Tuple_element<_Ty, _Tuple>
	{	// _Tuple_element for const
	typedef _Tuple_element<_Ty, _Tuple> _Mybase;
	typedef typename add_const<typename _Mybase::type>::type type;
	};

template<class _Ty,
	class _Tuple>
	struct _Tuple_element<_Ty, volatile _Tuple>
		: public _Tuple_element<_Ty, _Tuple>
	{	// _Tuple_element for volatile
	typedef _Tuple_element<_Ty, _Tuple> _Mybase;
	typedef typename add_volatile<typename _Mybase::type>::type type;
	};

template<class _Ty,
	class _Tuple>
	struct _Tuple_element<_Ty, const volatile _Tuple>
		: public _Tuple_element<_Ty, _Tuple>
	{	// _Tuple_element for const volatile
	typedef _Tuple_element<_Ty, _Tuple> _Mybase;
	typedef typename add_cv<typename _Mybase::type>::type type;
	};

	// TEMPLATE FUNCTION get (by index)
template<size_t _Index,
	class... _Types> inline
	_CONST_FUN typename tuple_element<_Index, tuple<_Types...> >::type&
		get(tuple<_Types...>& _Tuple) _NOEXCEPT
	{	// get reference to _Index element of tuple
	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
		_Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<size_t _Index,
	class... _Types> inline
	_CONST_FUN const typename tuple_element<_Index, tuple<_Types...> >::type&
		get(const tuple<_Types...>& _Tuple) _NOEXCEPT
	{	// get const reference to _Index element of tuple
	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
		_Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<size_t _Index,
	class... _Types> inline
	_CONST_FUN typename tuple_element<_Index, tuple<_Types...> >::type&&
		get(tuple<_Types...>&& _Tuple) _NOEXCEPT
	{	// get rvalue reference to _Index element of tuple
	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
		_Ttype;
	typedef typename tuple_element<_Index, tuple<_Types...> >::type&&
		_RRtype;
	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

 #if _HAS_CPP17
template<size_t _Index,
	class... _Types> inline
	_CONST_FUN const typename tuple_element<_Index, tuple<_Types...> >::type&&
		get(const tuple<_Types...>&& _Tuple) _NOEXCEPT
	{	// get rvalue reference to _Index element of tuple
	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
		_Ttype;
	typedef typename tuple_element<_Index, tuple<_Types...> >::type&&
		_RRtype;
	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
	}
 #endif /* _HAS_CPP17 */

	// TEMPLATE FUNCTION get (by type)
template<class _Ty,
	class... _Types> inline
	_CONST_FUN _Ty& get(tuple<_Types...>& _Tuple) _NOEXCEPT
	{	// get reference to _Ty element of tuple
	typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<class _Ty,
	class... _Types> inline
	_CONST_FUN const _Ty& get(const tuple<_Types...>& _Tuple) _NOEXCEPT
	{	// get const reference to _Ty element of tuple
	typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<class _Ty,
	class... _Types> inline
	_CONST_FUN _Ty&& get(tuple<_Types...>&& _Tuple) _NOEXCEPT
	{	// get rvalue reference to _Ty element of tuple
	typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
	return (_STD forward<_Ty>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

template<class _Ty,
	class... _Types> inline
	_CONST_FUN const _Ty&& get(const tuple<_Types...>&& _Tuple) _NOEXCEPT
	{	// get rvalue reference to _Ty element of tuple
	typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
	return (_STD forward<_Ty>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

	// TEMPLATE FUNCTION make_tuple
template<class... _Types> inline
	_CONST_FUN tuple<typename _Unrefwrap<_Types>::type...>
		make_tuple(_Types&&... _Args)
	{	// make tuple from elements
	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
	return (_Ttype(_STD forward<_Types>(_Args)...));
	}

	// TEMPLATE FUNCTION tie
template<class... _Types> inline
	_CONST_FUN tuple<_Types&...>
		tie(_Types&... _Args) _NOEXCEPT
	{	// make tuple from elements
	typedef tuple<_Types&...> _Ttype;
	return (_Ttype(_Args...));
	}

 #if _HAS_CPP17
	// TEMPLATE FUNCTION make_from_tuple
template<class _Ty,
	class _Tuple,
	size_t... _Idx>
_CONST_FUN _Ty _Make_from_tuple(_Tuple&& _Tpl,
	index_sequence<_Idx...>)
	{ // build _Ty constructor from _Tuple members
	return (_Ty(get<_Idx>(_STD forward<_Tuple>(_Tpl))...));
	}

template<class _Ty,
	class _Tuple>
_CONST_FUN _Ty make_from_tuple(_Tuple&& _Tpl)
	{	// make object _Ty from _Tuple members
	return (_Make_from_tuple<_Ty>(_STD forward<_Tuple>(_Tpl),
		make_index_sequence<tuple_size<decay_t<_Tuple> >::value>{}));
	}

	// TEMPLATE FUNCTION apply
template<class _Func,
	class _Tuple,
	size_t... _Idx>
_CONST_FUN decltype(auto) _Apply(_Func&& _Fn, _Tuple&& _Tpl,
	index_sequence<_Idx...>)
	{	// invoke the apply object
	return (_STD invoke(_STD forward<_Func>(_Fn),
		_STD get<_Idx>(_STD forward<_Tuple>(_Tpl))...));
	}

template<class _Func,
	class _Tuple>
_CONST_FUN decltype(auto) apply(_Func&& _Fn, _Tuple&& _Tpl)
	{	// call _Fn with tuple elements
	return (_Apply(_STD forward<_Func>(_Fn),
#if defined(__CODEGEARC__)
		_STD forward<_Tuple>(_Tpl),
#endif
		make_index_sequence<tuple_size<decay_t<_Tuple> >::value>{}));
	}
 #endif /* _HAS_CPP17 */

	// TEMPLATE FUNCTION forward_as_tuple
template<class... _Types> inline
	_CONST_FUN tuple<_Types&&...>
		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
	{	// forward arguments in a tuple
	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
	}

template<class... _Types> inline
	_CONST_FUN tuple<_Types&&...>
		forward_as_tuple(tuple<_Types&&...>&& _Tuple) _NOEXCEPT
	{	// forward a tuple
	return (tuple<_Types&&...>(_STD forward<tuple<_Types&&...> >(_Tuple)));
	}

	// TEMPLATE STRUCT _Cat_sequences
template<class _Seq_type1,
	class _Seq_type2>
	struct _Cat_sequences;

template<size_t... _Indexes1,
	size_t... _Indexes2>
	struct _Cat_sequences<integer_sequence<size_t, _Indexes1...>,
		integer_sequence<size_t, _Indexes2...> >
	{	// concatenates two integer_sequence types
	typedef integer_sequence<size_t, _Indexes1..., _Indexes2...> type;
	};

	// FORWARD DECLARATIONS
template<class _Ty,
	_INT_OR_SIZE_T _Size>
	class array;

template<size_t _Idx,
	class _Ty,
	_INT_OR_SIZE_T _Size>
	_CONST_FUN _Ty& get(array<_Ty, _Size>& _Arr) _NOEXCEPT;

template<size_t _Idx,
	class _Ty,
	_INT_OR_SIZE_T _Size>
	_CONST_FUN const _Ty& get(const array<_Ty, _Size>& _Arr) _NOEXCEPT;

template<size_t _Idx,
	class _Ty,
	_INT_OR_SIZE_T _Size>
	_CONST_FUN _Ty&& get(array<_Ty, _Size>&& _Arr) _NOEXCEPT;

	// TEMPLATE STRUCT _View_as_tuple
template<class _Ty,
	class... _For_array>
	struct _View_as_tuple
	{	// tuple_cat() supports only tuples, pairs, and arrays
	_STATIC_ASSERT2(_Always_false<_Ty>::value,
		"Unsupported tuple_cat arguments.");
	};

template<class... _Types>
	struct _View_as_tuple<tuple<_Types...> >
	{	// view a tuple as a tuple
	typedef tuple<_Types...> type;
	};

template<class _Ty1,
	class _Ty2>
	struct _View_as_tuple<pair<_Ty1, _Ty2> >
	{	// view a pair as a tuple
	typedef tuple<_Ty1, _Ty2> type;
	};

template<class _Ty,
	class... _Types>
	struct _View_as_tuple<array<_Ty, 0>, _Types...>
	{	// view an array as a tuple; ends recursion at 0
	typedef tuple<_Types...> type;
	};

template<class _Ty,
	_INT_OR_SIZE_T _Size,
	class... _Types>
	struct _View_as_tuple<array<_Ty, _Size>, _Types...>
		: _View_as_tuple<array<_Ty, _Size - 1>, _Ty, _Types...>
	{	// view an array as a tuple; counts down to 0
	};

	// TEMPLATE STRUCT _Repeat_for
template<size_t _Nx,
	class _Ty>
	struct _Repeat_for
		: integral_constant<size_t, _Nx>
	{	// repeats _Nx for each _Ty in a parameter pack
	};

	// TEMPLATE FUNCTION tuple_cat
template<class _Ret,
	class _Kx_arg,
	class _Ix_arg,
	size_t _Ix_next,
	class... _Tuples>
	struct _Tuple_cat2
	{	// determine tuple_cat's return type and _Kx/_Ix indices
	_STATIC_ASSERT2(sizeof...(_Tuples) == 0,
		"Unsupported tuple_cat arguments.");
	typedef _Ret type;
	typedef _Kx_arg _Kx_arg_seq;
	typedef _Ix_arg _Ix_arg_seq;
	};

template<class... _Types1,
	class _Kx_arg,
	size_t... _Ix,
	size_t _Ix_next,
	class... _Types2,
	class... _Rest>
	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg,
		integer_sequence<size_t, _Ix...>, _Ix_next,
		tuple<_Types2...>, _Rest...>
		: _Tuple_cat2<
			tuple<_Types1..., _Types2...>,
			typename _Cat_sequences<_Kx_arg,
				typename make_integer_sequence<size_t, sizeof...(_Types2)>
					::type>::type,
			integer_sequence<size_t, _Ix...,
				_Repeat_for<_Ix_next, _Types2>::value...>,
			_Ix_next + 1,
			_Rest...>
	{	// determine tuple_cat's return type and _Kx/_Ix indices
	};

template<class... _Tuples>
	struct _Tuple_cat1
		: _Tuple_cat2<tuple<>, integer_sequence<size_t>,
				integer_sequence<size_t>, 0,
			typename _View_as_tuple<typename decay<_Tuples>::type>::type...>
	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
	};

template<class _Ret,
	size_t... _Kx,
	size_t... _Ix,
	class _Ty> inline
	_CONST_FUN _Ret _Tuple_cat(integer_sequence<size_t, _Kx...>,
		integer_sequence<size_t, _Ix...>, _Ty&& _Arg)
	{	// concatenate tuples
	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
	}

template<class... _Tuples> inline
	_CONST_FUN typename _Tuple_cat1<_Tuples...>::type
		tuple_cat(_Tuples&&... _Tpls)
	{	// concatenate tuples
	typedef _Tuple_cat1<_Tuples...> _Cat1;
	return (_Tuple_cat<typename _Cat1::type>(
		typename _Cat1::_Kx_arg_seq(), typename _Cat1::_Ix_arg_seq(),
		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
	}

 #if _HAS_DELEGATING_CONSTRUCTORS
	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, sequence, sequence)
template<class _Ty1,
	class _Ty2>
	template<class _Tuple1,
		class _Tuple2,
		size_t... _Indexes1,
		size_t... _Indexes2> inline
		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
			_Tuple2& _Val2,
			integer_sequence<size_t, _Indexes1...>,
			integer_sequence<size_t, _Indexes2...>)
		: first(_STD get<_Indexes1>(_STD move(_Val1))...),
			second(_STD get<_Indexes2>(_STD move(_Val2))...)
		{	// construct from pair of tuples
		}

	// TEMPLATE CONSTRUCTOR pair::pair(piecewise_construct_t, tuple, tuple)
template<class _Ty1,
	class _Ty2>
	template<class... _Types1,
		class... _Types2> inline
		pair<_Ty1, _Ty2>::pair(piecewise_construct_t,
			tuple<_Types1...> _Val1,
			tuple<_Types2...> _Val2)
			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Types1...>::value)
				&& (is_nothrow_constructible<_Ty2, _Types2...>::value))
		: pair(_Val1, _Val2,
			make_integer_sequence<size_t, sizeof...(_Types1)>(),
			make_integer_sequence<size_t, sizeof...(_Types2)>())
		{	// construct from pair of tuples
		}

 #else /* _HAS_DELEGATING_CONSTRUCTORS */
	// TEMPLATE HELPER pair::_Init(tuple, integer_sequence)
template<class _Ty1,
	class _Ty2>
	template<class _Ty,
		class _Tuple,
		size_t... _Indexes> inline
		typename remove_cv<_Ty>::type pair<_Ty1, _Ty2>::_Init(
			_Tuple& _Val, integer_sequence<size_t, _Indexes...>)
		{	// construct from a tuple
		typedef typename remove_cv<_Ty>::type _Myty;
		return (_Myty(_STD get<_Indexes>(_STD move(_Val))...));
		}

	// TEMPLATE CONSTRUCTOR pair::pair(piecewise_construct_t, tuple, tuple)
template<class _Ty1,
	class _Ty2>
	template<class... _Types1,
		class... _Types2> inline
		pair<_Ty1, _Ty2>::pair(piecewise_construct_t,
			tuple<_Types1...> _Val1,
			tuple<_Types2...> _Val2)
			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Types1...>::value)
				&& (is_nothrow_constructible<_Ty2, _Types2...>::value))
		: first(_STD move(_Init<first_type>(_Val1,
				make_integer_sequence<size_t, sizeof...(_Types1)>()))),
			second(_STD move(_Init<second_type>(_Val2,
				make_integer_sequence<size_t, sizeof...(_Types2)>())))
		{	// construct from pair of tuples
		}
 #endif /* _HAS_DELEGATING_CONSTRUCTORS */

 #if _HAS_DEDUCTION_GUIDES
template<class... UTypes>
	tuple(UTypes...)
		-> tuple<UTypes...>;
template<class T1,
	class T2>
	tuple(pair<T1, T2>)
		-> tuple<T1, T2>;
template<class Alloc,
	class... UTypes>
	tuple(allocator_arg_t, Alloc, UTypes...)
		-> tuple<UTypes...>;
template<class Alloc,
	class T1,
	class T2>
	tuple(allocator_arg_t, Alloc, pair<T1, T2>)
		-> tuple<T1, T2>;
template<class Alloc,
	class... UTypes>
	tuple(allocator_arg_t, Alloc, tuple<UTypes...>)
		-> tuple<UTypes...>;
#endif /* _HAS_DEDUCTION_GUIDES */
_STD_END

namespace std {
	// TEMPLATE STRUCT uses_allocator
template<class... _Types,
	class _Alloc>
	struct uses_allocator<tuple<_Types...>, _Alloc>
		: true_type
	{	// true_type if container allocator enabled
	};
}	// namespace std

_STD_BEGIN
namespace tr1 {	// TR1 ADDITIONS
using _STD get;
using _STD ignore;
using _STD make_tuple;
using _STD ref;
using _STD tie;
using _STD tuple;
}	// namespace tr1

 #if _IS_GHS

 #if defined(__ghs_max_pack_value)
  #pragma pack (pop)
 #endif /* defined(__ghs_max_pack_value) */

 #if defined(__GHS_PRAGMAS)
  #pragma ghs enddata
  #pragma ghs end_cxx_lib_header
 #endif /* defined(__GHS_PRAGMAS) */

#endif /* _IS_GHS */
_STD_END
#endif /* _TUPLE_ */

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
 * V8.05/17:1422 */
