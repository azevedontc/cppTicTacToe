// type_traits standard header
#ifndef _TYPE_TRAITS_
#define _TYPE_TRAITS_
#include <yvals.h>

#if defined(__CODEGEARC__)
// workaround for LibSuite issue
#if defined(result_of)
#undef result_of
#endif
#if defined(result_of_t)
#undef result_of_t
#endif
  #if _CLANG

	#if __has_feature(is_convertible_to)
		#define _IS_CONVERTIBLE(_From, _To)	\
         : _Cat_base<is_void<_From>::value && is_void<_To>::value \
			|| __is_convertible_to(_From, _To)>
	 #endif /* __has_feature(is_convertible_to) */

  #endif /* _CLANG */

#endif

 #if _HAS_CPP17
 #include <execution>

 #else /* _HAS_CPP17 */
 #include <xstddef>
 #endif /* _HAS_CPP17 */

	// COMPILER SUPPORT MACROS

  #if 1400 <= _MSC_VER || __EDG_TYPE_TRAITS_ENABLED \
	|| defined(__CODEGEARC_CLANG__)

   #ifdef __CODEGEARC_CLANG__
    #define _IS_TRIVIALLY_CONSTRUCTIBLE	__is_trivially_constructible
   #endif /* defined(__CODEGEARC_CLANG__) */

		// VC++ V11 SUPPORT
  #define _IS_BASE_OF(_Base, _Der)	\
	: _Cat_base<__is_base_of(_Base, _Der)>
  #define _IS_CONVERTIBLE(_From, _To)	\
	: _Cat_base<is_void<_From>::value && is_void<_To>::value \
		|| __is_convertible_to(_From, _To)>
  #define _IS_UNION(_Ty)	\
	: _Cat_base<__is_union(_Ty)>
  #define _IS_CLASS(_Ty)	\
	: _Cat_base<__is_class(_Ty)>
  #define _IS_POD(_Ty)	\
	: _Cat_base<is_scalar<_Ty>::value \
		|| __has_trivial_constructor(_Ty) && __is_pod(_Ty)>
  #define _IS_EMPTY(_Ty)	\
	: _Cat_base<__is_empty(_Ty)>
  #define _IS_POLYMORPHIC(_Ty)	\
	: _Cat_base<__is_polymorphic(_Ty)>
  #define _IS_ABSTRACT(_Ty)	\
	: _Cat_base<__is_abstract(_Ty)>
  #define _IS_FINAL(_Ty)	\
	: _Cat_base<__is_final(_Ty)>
  #define _IS_STANDARD_LAYOUT(_Ty)	\
	: _Cat_base<__is_standard_layout(_Ty)>
  #define _IS_TRIVIAL(_Ty)	\
	: _Cat_base<!is_reference<_Ty>::value && __is_trivial(_Ty)>

  #define _HAS_TRIVIAL_CONSTRUCTOR(_Ty)	\
	: _Cat_base<is_pod<_Ty>::value \
		|| !is_array<_Ty>::value \
			&& __has_trivial_constructor(_Ty)>
  #define _HAS_TRIVIAL_COPY(_Ty)	\
	: _Cat_base<!is_array<_Ty>::value \
		&& (is_pod<typename remove_reference<_Ty>::type>::value \
			|| __is_trivially_copyable( \
				typename remove_reference<_Ty>::type))>
  #define _HAS_TRIVIAL_MOVE_CONSTRUCTOR(_Ty)	\
	: _Cat_base<!is_array<_Ty>::value \
		&& !is_function<_Ty>::value \
		&& !is_void<_Ty>::value \
		&& (is_pod<typename remove_reference<_Ty>::type>::value \
			|| __has_trivial_move_constructor( \
				typename remove_reference<_Ty>::type))>
  #define _HAS_TRIVIAL_ASSIGN(_Ty)	\
	: _Cat_base<!is_array<_Ty>::value \
		&& (is_pod<typename remove_reference<_Ty>::type>::value \
			|| __has_trivial_assign(typename remove_reference<_Ty>::type))>

  #define _IS_TRIVIALLY_ASSIGNABLE(_To, _From) \
	: _Cat_base<__is_trivially_assignable(_To, _From)>

  #define _HAS_TRIVIAL_MOVE_ASSIGN(_Ty)	\
	: _Cat_base<!is_array<_Ty>::value \
		&& !is_function<_Ty>::value \
		&& !is_void<_Ty>::value \
		&& (is_pod<typename remove_reference<_Ty>::type>::value \
			|| __has_trivial_move_assign( \
				typename remove_reference<_Ty>::type))>
  #define _HAS_TRIVIAL_DESTRUCTOR(_Ty)	\
	: _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value \
		|| __has_trivial_destructor(typename remove_reference<_Ty>::type)>

  #define _HAS_VIRTUAL_DESTRUCTOR(_Ty)	\
	: _Cat_base<__has_virtual_destructor(_Ty)>

  #define _UNDERLYING_TYPE(_Ty)	\
	__underlying_type(_Ty)
  #define _IS_LITERAL_TYPE(_Ty)	\
	: _Cat_base<__is_literal_type(_Ty) || is_void<_Ty>::value>

  #if _CLANG

   #if __has_feature(is_convertible_to)
		#define _IS_CONVERTIBLE(_From, _To)	\
         : _Cat_base<is_void<_From>::value && is_void<_To>::value \
			|| __is_convertible_to(_From, _To)>
   #endif /* __has_feature(is_convertible_to) */

  #endif /* _CLANG */

  #if _IS_GHS
   #define _IS_DESTRUCTIBLE(_Ty) 		\
	: _Cat_base<__is_destructible(_Ty)>

  #else /* _IS_GHS */
   #define _IS_DESTRUCTIBLE(_Ty) \
	: _Cat_base<!is_function<_Ty>::value> // APPROXIMATION
  #endif /* _IS_GHS */

  #define _IS_ENUM(_Ty)	\
	: _Cat_base<__is_enum(_Ty)>

 #else /* 1400 <= _MSC_VER || __EDG_TYPE_TRAITS_ENABLED */

  #if _GCC0X
		// GCC SUPPORT
  #define _IS_BASE_OF(_Base, _Der)	\
	: _Cat_base<__is_base_of(_Base, _Der)>
  #define _IS_UNION(_Ty)	\
	: _Cat_base<__is_union(_Ty)>
  #define _IS_CLASS(_Ty)	\
	: _Cat_base<__is_class(_Ty)>
  #define _IS_POD(_Ty)	\
	: _Cat_base<is_scalar<_Ty>::value \
		|| __is_pod(_Ty)>
  #define _IS_EMPTY(_Ty)	\
	: _Cat_base<__is_empty(_Ty)>
  #define _IS_POLYMORPHIC(_Ty)	\
	: _Cat_base<__is_polymorphic(_Ty)>
  #define _IS_ABSTRACT(_Ty)	\
	: _Cat_base<__is_abstract(_Ty)>
  #define _IS_FINAL(_Ty)	\
	: _Cat_base<__is_final(_Ty)>

// #if !_CLANG
//  #define _IS_AGGREGATE(_Ty)	\
//	: _Cat_base<__is_aggregate(_Ty)>
// #endif /* !_CLANG */

 #if 4 < __GNUC__ || 4 == __GNUC__ && 5 <= __GNUC_MINOR__
  #define _IS_STANDARD_LAYOUT(_Ty)	\
	: _Cat_base<__is_standard_layout(_Ty)>
  #define _IS_TRIVIAL(_Ty)	\
	: _Cat_base<__is_trivial(_Ty)>

 #else /* 4 < __GNUC__ etc. */
  #define _IS_STANDARD_LAYOUT(_Ty)	\
	: is_pod<_Ty>	/* APPROXIMATION */
  #define _IS_TRIVIAL(_Ty)	\
	: is_pod<_Ty>	/* APPROXIMATION */
 #endif /* 4 < __GNUC__ etc. */

  #define _HAS_TRIVIAL_CONSTRUCTOR(_Ty)	\
	: _Cat_base<is_pod<_Ty>::value \
		|| !is_array<_Ty>::value \
			&& __has_trivial_constructor(_Ty)>
  #define _HAS_TRIVIAL_COPY(_Ty)	\
	: _Cat_base<!is_array<_Ty>::value \
			&& __has_trivial_copy(_Ty)>
  #define _HAS_TRIVIAL_MOVE_CONSTRUCTOR(_Ty)	\
	: _Cat_base<!is_array<_Ty>::value \
		&& is_trivially_constructible< \
			typename remove_volatile<_Ty>::type, \
			typename add_rvalue_reference< \
				typename remove_volatile<_Ty>::type>::type>::value>
  #define _HAS_TRIVIAL_ASSIGN(_Ty)	\
	: _Cat_base<!is_array<_Ty>::value \
		&& (is_pod<typename remove_reference<_Ty>::type>::value \
			|| __has_trivial_assign(typename remove_reference<_Ty>::type))>

 #if _GCC5 || defined(__ghs)
  #define _IS_TRIVIALLY_ASSIGNABLE(_To, _From) \
	: _Cat_base<__is_trivially_assignable(_To, _From)>

 #else /* _GCC5 */
  #define _IS_TRIVIALLY_ASSIGNABLE(_To, _From) \
	: _Cat_base<is_assignable<_To, _From>::value \
		&& !has_virtual_destructor<_To>::value \
		&& !has_virtual_destructor<_From>::value>	/* APPROXIMATION */
 #endif /* _GCC5 || defined(__ghs) */

  #define _HAS_TRIVIAL_MOVE_ASSIGN(_Ty)	\
	: is_trivially_assignable<typename add_lvalue_reference< \
			typename remove_volatile<_Ty>::type>::type, \
		typename add_rvalue_reference< \
			typename remove_volatile<_Ty>::type>::type>::type
  #define _HAS_TRIVIAL_DESTRUCTOR(_Ty)	\
	: _Cat_base<is_pod<_Ty>::value || __has_trivial_destructor(_Ty)>
  #define _HAS_VIRTUAL_DESTRUCTOR(_Ty)	\
	: _Cat_base<__has_virtual_destructor(_Ty)>

 #if _IS_WRS
  #define _UNDERLYING_TYPE(_Ty) \
	__underlying_type(_Ty)

 #else /* IS_WRS */
  #define _UNDERLYING_TYPE(_Ty)	int	/* APPROXIMATION */
 #endif /* IS_WRS */

 #if _GCC48
  #define _IS_LITERAL_TYPE(_Ty)	\
	: _Cat_base<__is_literal_type(_Ty)>

 #else /* GCC48 */
  #define _IS_LITERAL_TYPE(_Ty)	\
	: _Cat_base<is_scalar<_Ty>::value
		|| is_reference<_Ty>::value>	/* APPROXIMATION */
 #endif /* GCC48 */

  #else /* _GCC0X */
#error unknown compiler
  #endif /* _GCC0X */

 #endif /* 1400 <= _MSC_VER etc. */

		// NOTHROW TRAITS

 #if defined(_NOTHROW_TEST)

 #elif _HAS_NOEXCEPT
  #define _NOTHROW_TEST(x)	noexcept(x)

 #else /* _HAS_NOEXCEPT */
  #define _NOTHROW_TEST(x)	true	/* APPROXIMATION */
 #endif /* _NOTHROW_TEST */

_STD_BEGIN
	// TEMPLATE CLASS _Ptr_traits
template<class _Ty>
	struct _Ptr_traits
	{	// basic definition
	};

template<class _Ty>
	struct _Ptr_traits<_Ty *>
	{	// pointer properties
	static const bool _Is_const = false;
	static const bool _Is_volatile = false;
	};

template<class _Ty>
	struct _Ptr_traits<const _Ty *>
	{	// pointer to const properties
	static const bool _Is_const = true;
	static const bool _Is_volatile = false;
	};

template<class _Ty>
	struct _Ptr_traits<volatile _Ty *>
	{	// pointer to volatile properties
	static const bool _Is_const = false;
	static const bool _Is_volatile = true;
	};

template<class _Ty>
	struct _Ptr_traits<const volatile _Ty *>
	{	// pointer to const volatile properties
	static const bool _Is_const = true;
	static const bool _Is_volatile = true;
	};

template<class _Ty>
	struct _Is_memfunptr
	{	// base class for member function pointer predicates
	typedef false_type _Bool_type;
	};

#define _IS_MEMFUNPTR(CALL_OPT, CV_OPT, REF_OPT) \
template<class _Ret, \
	class _Arg0, \
	class... _Types> \
	struct _Is_memfunptr<_Ret (CALL_OPT _Arg0::*)(_Types...) CV_OPT REF_OPT> \
		: _Arg_types<CV_OPT _Arg0 *, _Types...> \
	{	/* base class for member function pointer predicates */ \
	typedef true_type _Bool_type; \
	typedef _Ret result_type; \
	typedef _Arg0 _Class_type; \
	};

#if _HAS_NOEXCEPT
_MEMBER_CALL_CV_REF(_IS_MEMFUNPTR)
#undef _IS_MEMFUNPTR
#define _IS_MEMFUNPTR(CALL_OPT, CV_OPT, REF_OPT) \
template<class _Ret, \
	class _Arg0, \
	class... _Types> \
	struct _Is_memfunptr< \
			_Ret (CALL_OPT _Arg0::*)(_Types...) CV_OPT REF_OPT noexcept> \
		: _Arg_types<CV_OPT _Arg0 *, _Types...> \
	{	/* base class for member function pointer predicates */ \
	typedef true_type _Bool_type; \
	typedef _Ret result_type; \
	typedef _Arg0 _Class_type; \
	};

_MEMBER_CALL_CV_REF(_IS_MEMFUNPTR)
#undef _IS_MEMFUNPTR
#endif	/* _NOEXCEPT */

#define _IS_MEMFUNPTR_ELLIPSIS(CV_OPT, REF_OPT) \
template<class _Ret, \
	class _Arg0, \
	class... _Types> \
	struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) CV_OPT REF_OPT> \
	{	/* no calling conventions for ellipsis */ \
	typedef true_type _Bool_type; \
	typedef _Ret result_type; \
	typedef _Arg0 _Class_type; \
	};

_CLASS_DEFINE_CV_REF(_IS_MEMFUNPTR_ELLIPSIS)
#undef _IS_MEMFUNPTR_ELLIPSIS

	// TYPE MODIFIERS
template<class _Ty>
	struct _Has_cv_ref_qual
		: false_type
	{	// no const/volatile &/&& function qualifiers
	};

template<class _Ty,
	class... _Types>
	struct _Has_cv_ref_qual<_Ty(_Types...) const>
		: true_type
	{	// const function qualifier
	};

template<class _Ty,
	class... _Types>
	struct _Has_cv_ref_qual<_Ty(_Types...) volatile>
		: true_type
	{	// volatile function qualifier
	};

template<class _Ty,
	class... _Types>
	struct _Has_cv_ref_qual<_Ty(_Types...) const volatile>
		: true_type
	{	// const volatile function qualifier
	};

template<class _Ty,
	class... _Types>
	struct _Has_cv_ref_qual<_Ty(_Types...) &>
		: true_type
	{	// & function qualifier
	};

template<class _Ty,
	class... _Types>
	struct _Has_cv_ref_qual<_Ty(_Types...) const&>
		: true_type
	{	// const& function qualifier
	};

template<class _Ty,
	class... _Types>
	struct _Has_cv_ref_qual<_Ty(_Types...) volatile&>
		: true_type
	{	// volatile& function qualifier
	};

template<class _Ty,
	class... _Types>
	struct _Has_cv_ref_qual<_Ty(_Types...) const volatile&>
		: true_type
	{	// const volatile& function qualifier
	};

template<class _Ty,
	class... _Types>
	struct _Has_cv_ref_qual<_Ty(_Types...) &&>
		: true_type
	{	// && function qualifier
	};

template<class _Ty,
	class... _Types>
	struct _Has_cv_ref_qual<_Ty(_Types...) const&&>
		: true_type
	{	// const&& function qualifier
	};

template<class _Ty,
	class... _Types>
	struct _Has_cv_ref_qual<_Ty(_Types...) volatile&&>
		: true_type
	{	// volatile&& function qualifier
	};

template<class _Ty,
	class... _Types>
	struct _Has_cv_ref_qual<_Ty(_Types...) const volatile&&>
		: true_type
	{	// const volatile&& function qualifier
	};

	// TEMPLATE CLASS add_const
template<class _Ty>
	struct add_const
	{	// add top level const qualifier
	typedef const _Ty type;
	};

	// TEMPLATE CLASS add_volatile
template<class _Ty>
	struct add_volatile
	{	// add top level volatile qualifier
	typedef volatile _Ty type;
	};

	// TEMPLATE CLASS add_cv
template<class _Ty>
	struct add_cv
	{	// add top level const and volatile qualifiers
	typedef const volatile _Ty type;
	};

 #if _HAS_CPP11
	// TEMPLATE CLASS add_lvalue_reference
template<class _Ty,
	bool _Is_identity = false>
	struct _Do_add_lvalue_reference
	{	// add lvalue reference
	typedef _Ty& type;
	};

template<class _Ty>
	struct _Do_add_lvalue_reference<_Ty, true>
		: _Identity<_Ty>
	{	// add lvalue reference (inherits type)
	};

template<class _Ty>
	struct add_lvalue_reference
		: _Do_add_lvalue_reference<_Ty,
			_Has_cv_ref_qual<_Ty>::value>
	{	// add lvalue reference (inherits type)
	};

 #else /* _HAS_CPP11 */
	// TEMPLATE CLASS add_lvalue_reference
template<class _Ty>
	struct add_lvalue_reference
	{	// add lvalue reference
	typedef _Ty& type;
	};
 #endif /* _HAS_CPP11 */

#define _ADD_LVALUE_REFERENCE_VOID(CV_OPT) \
template<> \
	struct add_lvalue_reference<CV_OPT void> \
	{	/* add lvalue reference */ \
	typedef CV_OPT void type; \
	};

_CLASS_DEFINE_CV(_ADD_LVALUE_REFERENCE_VOID)
#undef _ADD_LVALUE_REFERENCE_VOID

	// TEMPLATE CLASS add_rvalue_reference
template<class _Ty,
	bool _Is_identity = false>
	struct _Do_add_rvalue_reference
	{	// add rvalue reference
	typedef typename remove_reference<_Ty>::type&& type;
	};

template<class _Ty>
	struct _Do_add_rvalue_reference<_Ty, true>
		: _Identity<_Ty>
	{	// add rvalue reference (inherits type)
	};

template<class _Ty>
	struct add_rvalue_reference
		: _Do_add_rvalue_reference<_Ty,
			_Has_cv_ref_qual<_Ty>::value>
	{	// add rvalue reference (inherits type)
	};

template<class _Ty>
	struct add_rvalue_reference<_Ty&>
	{	// add rvalue reference
	typedef _Ty& type;
	};

#define _ADD_RVALUE_REFERENCE_VOID(CV_OPT) \
template<> \
	struct add_rvalue_reference<CV_OPT void> \
	{	/* add rvalue reference */ \
	typedef CV_OPT void type; \
	};

_CLASS_DEFINE_CV(_ADD_RVALUE_REFERENCE_VOID)
#undef _ADD_RVALUE_REFERENCE_VOID

	// TEMPLATE FUNCTION declval
template<class _Ty>
	typename add_rvalue_reference<_Ty>::type
		declval() _NOEXCEPT;

	// TEMPLATE CLASS remove_extent
template<class _Ty>
	struct remove_extent
	{	// remove array extent
	typedef _Ty type;
	};

template<class _Ty,
	size_t _Ix>
	struct remove_extent<_Ty[_Ix]>
	{	// remove array extent
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_extent<_Ty[]>
	{	// remove array extent
	typedef _Ty type;
	};

	// TEMPLATE CLASS remove_all_extents
template<class _Ty>
	struct remove_all_extents
	{	// remove all array extents
	typedef _Ty type;
	};

template<class _Ty,
	size_t _Ix>
	struct remove_all_extents<_Ty[_Ix]>
	{	// remove all array extents
	typedef typename remove_all_extents<_Ty>::type type;
	};

template<class _Ty>
	struct remove_all_extents<_Ty[]>
	{	// remove all array extents
	typedef typename remove_all_extents<_Ty>::type type;
	};

	// TEMPLATE CLASS remove_pointer
template<class _Ty>
	struct remove_pointer
	{	// remove pointer
	typedef _Ty type;
	};

#define _REMOVE_POINTER(CV_OPT) \
template<class _Ty> \
	struct remove_pointer<_Ty *CV_OPT> \
	{	/* remove pointer */ \
	typedef _Ty type; \
	};

_CLASS_DEFINE_CV(_REMOVE_POINTER)
#undef _REMOVE_POINTER

	// TEMPLATE CLASS add_pointer

 #if _HAS_CPP11
template<class _Ty,
	bool _Is_identity = false>
	struct _Do_add_pointer
	{	// add pointer
	typedef typename remove_reference<_Ty>::type *type;
	};

template<class _Ty>
	struct _Do_add_pointer<_Ty, true>
		: _Identity<_Ty>
	{	// add pointer (inherits type)
	};

template<class _Ty>
	struct add_pointer
		: _Do_add_pointer<_Ty, _Has_cv_ref_qual<_Ty>::value>
	{	// add pointer (inherits type)
	};

 #else /* _HAS_CPP11 */
template<class _Ty>
	struct add_pointer
	{	// add pointer
	typedef typename remove_reference<_Ty>::type *type;
	};
 #endif /* _HAS_CPP11 */

	// TYPE PREDICATES
	// TEMPLATE CLASS is_void
template<class _Ty>
	struct _Is_void
		: false_type
	{	// determine whether _Ty is void
	};

template<>
	struct _Is_void<void>
		: true_type
	{	// determine whether _Ty is void
	};

template<class _Ty>
	struct is_void
		: _Is_void<typename remove_cv<_Ty>::type>
	{	// determine whether _Ty is void
	};

	// TEMPLATE CLASS is_array
template<class _Ty>
	struct is_array
		: false_type
	{	// determine whether _Ty is an array
	};

template<class _Ty,
	size_t _Nx>
	struct is_array<_Ty[_Nx]>
		: true_type
	{	// determine whether _Ty is an array
	};

template<class _Ty>
	struct is_array<_Ty[]>
		: true_type
	{	// determine whether _Ty is an array
	};

 #if _HAS_CPP11
	// TEMPLATE CLASS is_lvalue_reference
template<class _Ty>
	struct is_lvalue_reference
		: false_type
	{	// determine whether _Ty is an lvalue reference
	};

template<class _Ty>
	struct is_lvalue_reference<_Ty&>
		: true_type
	{	// determine whether _Ty is an lvalue reference
	};

	// TEMPLATE CLASS is_rvalue_reference
template<class _Ty>
	struct is_rvalue_reference
		: false_type
	{	// determine whether _Ty is an rvalue reference
	};

template<class _Ty>
	struct is_rvalue_reference<_Ty&&>
		: true_type
	{	// determine whether _Ty is an rvalue reference
	};

	// TEMPLATE CLASS is_reference
template<class _Ty>
	struct is_reference
		: _Cat_base<is_lvalue_reference<_Ty>::value
		|| is_rvalue_reference<_Ty>::value>
	{	// determine whether _Ty is a reference
	};

 #else /* _HAS_CPP11 */
	// TEMPLATE CLASS is_reference
template<class _Ty>
	struct is_reference
		: false_type
	{	// determine whether _Ty is a reference
	};

template<class _Ty>
	struct is_reference<_Ty&>
		: true_type
	{	// determine whether _Ty is a reference
	};
 #endif /* _HAS_CPP11 */

	// TEMPLATE CLASS is_member_object_pointer
template<class _Ty,
	bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
	struct _Is_member_object_pointer
		: false_type
	{	// determine whether _Ty is a pointer to member object
	};

template<class _Ty1,
	class _Ty2>
	struct _Is_member_object_pointer<_Ty1 _Ty2::*, false>
		: true_type
	{	// determine whether _Ty is a pointer to member object
	typedef _Ty2 _Class_type;
	};

template<class _Ty>
	struct is_member_object_pointer
		: _Is_member_object_pointer<typename remove_cv<_Ty>::type>::type
	{	// determine whether _Ty is a pointer to member object
	};

	// TEMPLATE CLASS is_member_function_pointer
template<class _Ty>
	struct is_member_function_pointer
		: _Is_memfunptr<typename remove_cv<_Ty>::type>::_Bool_type
	{	// determine whether _Ty is a pointer to member function
	};

	// TEMPLATE CLASS is_pointer
template<class _Ty>
	struct _Is_pointer
		: false_type
	{	// determine whether _Ty is a pointer
	};

template<class _Ty>
	struct _Is_pointer<_Ty *>
		: _Cat_base<!is_member_object_pointer<_Ty *>::value
		&& !is_member_function_pointer<_Ty *>::value>
	{	// determine whether _Ty is a pointer
	};

template<class _Ty>
	struct is_pointer
		: _Is_pointer<typename remove_cv<_Ty>::type>
	{	// determine whether _Ty is a pointer
	};

	// TEMPLATE CLASS is_null_pointer
template<class _Ty>
	struct is_null_pointer
		: _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
	{	// determine whether _Ty is nullptr_t
	};

	// TEMPLATE CLASS is_union
template<class _Ty>
	struct is_union
		_IS_UNION(_Ty)
	{	// determine whether _Ty is a union
	};

	// TEMPLATE CLASS is_class
template<class _Ty>
	struct is_class
		_IS_CLASS(_Ty)
	{	// determine whether _Ty is a class
	};

	// TEMPLATE CLASS is_fundamental
template<class _Ty>
	struct is_fundamental
		: _Cat_base<is_arithmetic<_Ty>::value
		|| is_void<_Ty>::value
		|| is_null_pointer<_Ty>::value>
	{	// determine whether _Ty is a fundamental type
	};

	// TEMPLATE CLASS is_object
template<class _Ty>
	struct is_object
		: _Cat_base<!is_function<_Ty>::value
		&& !is_reference<_Ty>::value
		&& !is_void<_Ty>::value>
	{	// determine whether _Ty is an object type
	};

	// TEMPLATE CLASS is_convertible
 #ifndef _IS_CONVERTIBLE
		// TEMPLATE STRUCT _Is_convertible
  #define _IS_CONVERTIBLE(_From, _To)	\
		: _Cat_base<is_void<_From>::value && is_void<_To>::value \
		|| _Is_convertible< \
			!is_void<_From>::value && !is_function<_From>::value \
				&& !is_void<_To>::value && !is_function<_To>::value, \
			_From, _To>::type::value>

template<bool,
	class _From,
	class _To>
	struct _Is_convertible
		: false_type
	{	// determines whether _From is convertible to _To
	};

template<class _From,
	class _To>
	struct _Is_convertible<true, _From, _To>
	{	// determines whether _From is convertible to _To
	template<class _Uto>
		static auto _Fn(int, _Uto)
			-> true_type;
	template<class _Uto>
		static auto _Fn(_Wrap_int, ...)
			-> false_type;

	typedef decltype(_Fn<_To>(0, _STD declval<_From>())) type;
	};
 #endif /* _IS_CONVERTIBLE */

template<class _From,
	class _To>
	struct is_convertible

 #if _CLANG	/* compiler test */
		_IS_CONVERTIBLE(typename remove_volatile<_From>::type,
			typename remove_volatile<_To>::type)

 #else /* _CLANG */
		_IS_CONVERTIBLE(_From, _To)
 #endif /* _CLANG */

	{	// determine whether _From is convertible to _To
	};

 #ifndef _IS_ENUM
		// TEMPLATE STRUCT _Is_composite
template<class _Ty>
	struct _Is_composite
	{	// determines whether _Ty is a struct/class/union
	template<class _Uty>
		static auto _Fn(int)
			-> decltype((const volatile int _Uty::*)0, true_type());
	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_Ty>(0)) type;

	static const bool value = type::value;
	};

template<class _Ty>
	struct _Is_enum
		: _Cat_base<!is_void<_Ty>::value
			&& !is_arithmetic<_Ty>::value
			&& !is_array<_Ty>::value
			&& !_Is_composite<_Ty>::value
			&& is_convertible<_Ty, int>::value>
	{	// determine whether _Ty is an enumerated type
	};

template<class _Ty>
	struct _Is_enum<_Ty&>
		: false_type
	{	// determine whether _Ty is an enumerated type
	};

  #define _IS_ENUM(_Ty)	: _Is_enum<_Ty>
 #endif /* _IS_ENUM */

	// TEMPLATE CLASS is_enum
template<class _Ty>
	struct is_enum
		_IS_ENUM(_Ty)
	{	// determine whether _Ty is an enumerated type
	};

	// TEMPLATE CLASS is_compound
template<class _Ty>
	struct is_compound
		: _Cat_base<!is_fundamental<_Ty>::value>
	{	// determine whether _Ty is a compound type
	};

	// TEMPLATE CLASS is_member_pointer
template<class _Ty>
	struct is_member_pointer
		: _Cat_base<is_member_object_pointer<_Ty>::value
		|| is_member_function_pointer<_Ty>::value>
	{	// determine whether _Ty is a pointer to member
	};

	// TEMPLATE CLASS is_scalar
template<class _Ty>
	struct is_scalar
		: _Cat_base<is_arithmetic<_Ty>::value
		|| is_enum<_Ty>::value
		|| is_pointer<_Ty>::value
		|| is_member_pointer<_Ty>::value
		|| is_null_pointer<_Ty>::value>
	{	// determine whether _Ty is a scalar type
	};

	// TEMPLATE CLASS is_const
template<class _Ty>
	struct is_const
		: _Cat_base<_Ptr_traits<_Ty *>::_Is_const
		&& !is_function<_Ty>::value>
	{	// determine whether _Ty is const qualified
	};

template<class _Ty,
	size_t _Nx>
	struct is_const<_Ty[_Nx]>
		: false_type
	{	// determine whether _Ty is const qualified
	};

template<class _Ty,
	size_t _Nx>
	struct is_const<const _Ty[_Nx]>
		: true_type
	{	// determine whether _Ty is const qualified
	};

template<class _Ty>
	struct is_const<_Ty&>
		: false_type
	{	// determine whether _Ty is const qualified
	};

template<class _Ty>
	struct is_const<_Ty&&>
		: false_type
	{	// determine whether _Ty is const qualified
	};

	// TEMPLATE CLASS is_volatile
template<class _Ty>
	struct is_volatile
		: _Cat_base<_Ptr_traits<_Ty *>::_Is_volatile
		&& !is_function<_Ty>::value>
	{	// determine whether _Ty is volatile qualified
	};

template<class _Ty>
	struct is_volatile<_Ty&>
		: false_type
	{	// determine whether _Ty is volatile qualified
	};

template<class _Ty>
	struct is_volatile<_Ty&&>
		: false_type
	{	// determine whether _Ty is volatile qualified
	};

	// TEMPLATE CLASS _Composite_ptr
template<class _Ty1,
	class _Ty2>
	struct _Copy_cv
	{	// copy attributes from _Ty1 to _Ty2
	typedef conditional<is_const<_Ty1>::value,
		typename add_const<_Ty2>::type,
		_Ty2> _Tx;
	typedef conditional<is_volatile<_Ty1>::value,
		typename add_volatile<_Tx>::type,
		_Tx> type;
	};

template<class _Ty1,
	class _Ty2>
	using _Copy_cv_t = typename _Copy_cv<_Ty1, _Ty2>::type;

template<class _Ty1,
	class _Ty2>
	struct _Composite_ptr
	{	// determine composite pointer type
	typedef
		typename conditional<is_same<_Ty1 *, nullptr_t>::value,
			_Ty2 *,
		typename conditional<is_same<_Ty2 *, nullptr_t>::value,
			_Ty1 *,
		typename conditional<is_same<typename remove_cv<_Ty1>::type,
			void>::value,
			_Copy_cv_t<_Ty1, _Ty2> *,
			_Copy_cv_t<_Ty2, _Ty1> *
			>::type >::type >::type type;
	};

template<class _Ty1,
	class _Ty2>
	using _Composite_ptr_t = typename _Composite_ptr<_Ty1, _Ty2>::type;

	// TEMPLATE CLASS is_pod
template<class _Ty>
	struct _Is_pod
		_IS_POD(_Ty)
	{	// determine whether _Ty is a POD type
	};

template<class _Ty>
	struct is_pod
		: _Is_pod<typename remove_all_extents<_Ty>::type>
	{	// determine whether _Ty is a POD type
	};

	// TEMPLATE CLASS is_empty
template<class _Ty>
	struct is_empty
		_IS_EMPTY(_Ty)
	{	// determine whether _Ty is an empty class
	};

	// TEMPLATE CLASS is_polymorphic
template<class _Ty>
	struct is_polymorphic
		_IS_POLYMORPHIC(_Ty)
	{	// determine whether _Ty is a polymorphic type
	};

	// TEMPLATE CLASS is_abstract
template<class _Ty>
	struct is_abstract
		_IS_ABSTRACT(_Ty)
	{	// determine whether _Ty is an abstract class
	};

	// TEMPLATE CLASS is_standard_layout
template<class _Ty>
	struct is_standard_layout _IS_STANDARD_LAYOUT(_Ty)
	{	// determine whether _Ty is standard layout
	};

	// TEMPLATE CLASS is_literal_type
template<class _Ty>
	struct is_literal_type
		_IS_LITERAL_TYPE(_Ty)
	{	// determine whether _Ty is a literal type
	};

	// TEMPLATE CLASS is_trivial
template<class _Ty>
	struct is_trivial
		_IS_TRIVIAL(_Ty)
	{	// determine whether _Ty is trivial
	};

	// TEMPLATE CLASS has_virtual_destructor
template<class _Ty>
	struct has_virtual_destructor
		_HAS_VIRTUAL_DESTRUCTOR(_Ty)
	{	// determine whether _Ty has a virtual destructor
	};

		// CONSTRUCTIBLE/ASSIGNABLE TRAITS
	// TEMPLATE CLASS is_constructible
#if defined(__CODEGEARC__) && __has_extension(is_constructible)
template <class _Ty,
	 class... _Types>
	 struct is_constructible
	 	: bool_constant<__is_constructible(_Ty, _Types...)>
	{
	};
#else
template<bool,
	class _Ty,
	class... _Types>
	struct _Is_constructible
		: false_type
	{	// not constructible if not object type
	};

template<class _Ty,
	class... _Types>
	struct _Is_constructible<true, _Ty, _Types...>
	{	// tests for valid constructor
#if _CLANG
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wint-to-pointer-cast"
#endif /* _CLANG */
	template<class _Uty>
		static auto _Fn(int)
			-> decltype((void)_Uty(_STD declval<_Types>()...),
				true_type());
#if _CLANG
 #pragma clang diagnostic pop
#endif /* _CLANG */
	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_Ty>(0)) type;
	};

template<class _Ty,
	class... _Types>
	struct is_constructible
		: _Is_constructible<!is_void<_Ty>::value
				&& (is_object<_Ty>::value || is_reference<_Ty>::value)
					&& (!is_scalar<_Ty>::value || sizeof...(_Types) <= 1),
			typename remove_all_extents<_Ty>::type,
			_Types...>::type
	{	// determine whether _Ty(_Types...) is constructible
	};
#endif  // __CODEGEARC__

	// TEMPLATE CLASS is_copy_constructible
#if defined(__CODEGEARC__) && __has_extension(is_constructible)
template <class _Ty>
    struct is_copy_constructible
        : bool_constant<__is_constructible(_Ty, typename add_lvalue_reference<const _Ty>::type)>
        {
        };
#else
template<bool,
	class _Ty>
	struct _Is_cc
		: false_type
	{	// here if void or array
	};

template<class _Ty>
	struct _Is_cc<true, _Ty>
		: is_constructible<_Ty, const _Ty&>
	{	// here if not void
	};

template<class _Ty>
	struct _Is_cc<true, _Ty&>
		: is_constructible<_Ty&, _Ty&>
	{	// here if reference and not void
	};

template<class _Ty>
	struct is_copy_constructible
		: is_constructible<_Ty, typename add_lvalue_reference<
			typename std::add_const<_Ty>::type>::type>
	{	// determine whether _Ty has a copy constructor
	};
#endif // __CODEGEARC__

	// TEMPLATE CLASS is_default_constructible
template<class _Ty>
	struct is_default_constructible
		: is_constructible<_Ty>::type
	{	// determine whether _Ty has a default constructor
	};

	// TEMPLATE CLASS is_move_constructible
template<bool,
	class _Ty>
	struct _Is_mc
		: false_type
	{	// here if void or array
	};

template<class _Ty>
	struct _Is_mc<true, _Ty>
		: is_constructible<_Ty, _Ty&&>
	{	// here if not void
	};

template<class _Ty>
	struct _Is_mc<true, _Ty&>
		: is_constructible<_Ty, _Ty&&>
	{	// here if reference and not void
	};

template<class _Ty>
	struct is_move_constructible
		: _Is_mc<!is_void<_Ty>::value && !is_array<_Ty>::value, _Ty>
	{	// determine whether _Ty has a move constructor
	};

	// TEMPLATE CLASS is_implicitly_constructible [ADDED WITH C++17]
 template<class _Ty,
	class... _Args>
	struct is_implicitly_constructible
	{	// tests for valid implicit constructor
	template<class _Tx>
		struct test_struct
		{	// just holds value declaration
		_Tx value;
		};

	template<class _Tx = _Ty>
		static auto evaluate(int) ->
			decltype(test_struct<_Tx>{{_STD declval<_Args>()... }},
				_STD true_type{});
	 template<class = _Ty>
		static auto evaluate(float) ->
			_STD false_type;

	static constexpr bool value = decltype(evaluate(0))::value;
	};

template<class _Ty>
	using is_implicitly_default_constructible =
		is_implicitly_constructible<_Ty>;

	// TEMPLATE CLASS is_assignable
template<bool,
	class _To,
	class _From>
	struct _Is_assignable
		: false_type
	{	// invalid assign expression
	};

template<class _To,
	class _From>
	struct _Is_assignable<true, _To, _From>
	{	// tests for valid assign expression
	template<class _Uty>
		static auto _Fn(int)
			-> decltype((void)(_STD declval<_Uty>() = _STD declval<_From>()),
				true_type());

	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_To>(0)) type;
	};

template<class _To,
	class _From>
	struct is_assignable
		: _Is_assignable<
			is_object<typename remove_reference<_To>::type>::value
			&& !is_array<typename remove_reference<_To>::type>::value
			&& is_object<typename remove_reference<_From>::type>::value
			&& !is_array<typename remove_reference<_From>::type>::value,
			_To, _From>::type
//		_IS_ASSIGNABLE(_To, _From)
	{	// determine whether _From can be assigned to _To
	};

	// TEMPLATE CLASS is_copy_assignable
template<bool,
	class _Ty>
	struct _Is_ca
		: false_type
	{	// here if void
	};

template<class _Ty>
	struct _Is_ca<false, _Ty>
		: is_assignable<_Ty&, const _Ty&>
	{	// here if not void
	};

template<class _Ty>
	struct is_copy_assignable
		: _Is_ca<is_void<_Ty>::value, _Ty>
	{	// determine whether _Ty has a copy assignment operator
	};

	// TEMPLATE CLASS is_move_assignable
template<bool,
	class _Ty>
	struct _Is_ma
		: false_type
	{	// here if void
	};

template<class _Ty>
	struct _Is_ma<false, _Ty>
		: is_assignable<_Ty&, _Ty&&>
	{	// here if not void
	};

template<class _Ty>
	struct is_move_assignable
		: _Is_ma<is_void<_Ty>::value, _Ty>
	{	// determine whether _Ty has a move assignment operator
	};

	// TEMPLATE CLASS is_destructible
 #ifndef _IS_DESTRUCTIBLE
	#define _IS_DESTRUCTIBLE(_Ty) \
		: true_type	// APPROXIMATION
 #endif /* _IS_DESTRUCTIBLE */

template<bool,
	class _Ty>
	struct _Is_destructible
		_IS_DESTRUCTIBLE(_Ty)
	{	// determine whether _Ty is destructible
	};

template<class _Ty>
	struct _Is_destructible<false, _Ty>
		: false_type
	{	// _Ty is not destructible
	};

template<class _Ty>
	struct is_destructible
		: _Is_destructible<!is_void<_Ty>::value && !is_function<_Ty>::value,
			typename remove_cv<_Ty>::type>
	{	// determine whether _Ty has a destructor
	};

		// TRIVIAL TRAITS
	// TEMPLATE CLASS is_trivially_constructible

 #if defined(_IS_TRIVIALLY_CONSTRUCTIBLE)
template<class _Ty,
	class... _Types>
	struct is_trivially_constructible
		: _Cat_base<_IS_TRIVIALLY_CONSTRUCTIBLE(_Ty, _Types...)>
	{	// determine whether _Ty(_Types...) is trivially constructible
	};

 #else /* defined(_IS_TRIVIALLY_CONSTRUCTIBLE) */
template<class _Ty,
	class... _Types>
	struct is_trivially_constructible
		: _Cat_base<is_trivial<_Ty>::value
			&& is_constructible<_Ty, _Types...>::value>	// APPROXIMATION
	{	// determine whether _Ty(_Types...) is trivially constructible
	};

template<class _Ty>
	struct is_trivially_constructible<_Ty, _Ty>
		_HAS_TRIVIAL_COPY(_Ty)
	{	// determine whether _Ty(_Arg) is trivially copy constructible
	};

template<class _Ty>
	struct is_trivially_constructible<_Ty>
		_HAS_TRIVIAL_CONSTRUCTOR(_Ty)
	{	// determine whether _Ty(_Arg) is trivially default constructible
	};
 #endif /* defined(_IS_TRIVIALLY_CONSTRUCTIBLE) */

	// TEMPLATE CLASS is_trivially_copy_constructible
template<bool,
	class _Ty>
	struct _Is_tcc
		: false_type
	{	// here if void or array
	};

template<class _Ty>
	struct _Is_tcc<false, _Ty>
		: is_trivially_constructible<_Ty, const _Ty&>
	{	// here if not void
	};

template<class _Ty>
	struct is_trivially_copy_constructible
		: _Is_tcc<is_void<_Ty>::value || is_array<_Ty>::value, _Ty>
	{	// determine whether _Ty has a trivial copy constructor
	};

	// TEMPLATE CLASS is_trivially_default_constructible
template<class _Ty>
	struct is_trivially_default_constructible
		: is_trivially_constructible<_Ty>::type
	{	// determine whether _Ty has a trivial default constructor
	};

	// TEMPLATE CLASS is_trivially_move_constructible
template<bool,
	class _Ty>
	struct _Is_tmc
		: false_type
	{	// here if void or array
	};

template<class _Ty>
	struct _Is_tmc<false, _Ty>
		: is_trivially_constructible<_Ty, _Ty&&>
	{	// here if not void
	};

template<class _Ty>
	struct is_trivially_move_constructible
		: _Is_tmc<is_void<_Ty>::value || is_array<_Ty>::value, _Ty>
	{	// determine whether _Ty has a trivial move constructor
	};

	// TEMPLATE CLASS is_trivially_assignable
template<class _To,
	class _From>
	struct is_trivially_assignable
		_IS_TRIVIALLY_ASSIGNABLE(_To, _From)
	{	// determine whether _From can be assigned to _To, trivially
	};

	// TEMPLATE CLASS is_trivially_copy_assignable
template<bool,
	class _Ty>
	struct _Is_tca
		: false_type
	{	// here if void
	};

template<class _Ty>
	struct _Is_tca<false, _Ty>
		: is_trivially_assignable<_Ty&, const _Ty&>
	{	// here if not void
	};

template<class _Ty>
	struct is_trivially_copy_assignable
		: _Is_tca<is_void<_Ty>::value
			|| has_virtual_destructor<_Ty>::value, _Ty>
	{	// determine whether _Ty has a trivial copy assignment operator
	};

	// TEMPLATE CLASS is_trivially_copyable
template<class _Ty>
	struct is_trivially_copyable
#if defined(__CODEGEARC__)
		: _Cat_base<__is_trivially_copyable(_Ty)>
#else
		: is_trivially_copy_assignable<typename remove_const<_Ty>::type>
#endif
	{	// determine whether _Ty is trivially copyable
	};

	// TEMPLATE CLASS has_unique_object_representations
template<class _Ty>
	struct has_unique_object_representations
		: is_trivially_copyable<_Ty>::type	// APPROXIMATION
	{	// determine whether _Ty has unique_object_representations
	};

	// TEMPLATE CLASS is_trivially_move_assignable

  #ifdef __CODEGEARC_CLANG__
	template<class _Ty>
		struct is_trivially_move_assignable
			: is_trivially_assignable<
				typename add_lvalue_reference<_Ty>::type,
				typename add_rvalue_reference<_Ty>::type>
	{	// determine whether _Ty has a trivial move assignment operator
	};

  #else /* defined(__CODEGEARC_CLANG__) */
template<class _Ty>
	struct is_trivially_move_assignable
		_HAS_TRIVIAL_MOVE_ASSIGN(_Ty)
	{	// determine whether _Ty has a trivial move assignment operator
	};
  #endif /* defined(__CODEGEARC_CLANG__) */

	// TEMPLATE CLASS is_trivially_destructible
template<class _Ty>
	struct is_trivially_destructible
		_HAS_TRIVIAL_DESTRUCTOR(_Ty)
	{	// determine whether _Ty has a trivial destructor
	};

	// TEMPLATE CLASS is_nothrow_constructible
template<bool,
	class _Ty,
	class... _Types>
	struct _Is_ntc
		: false_type
	{	// false by default
	};

template<class _Ty,
	class... _Types>
	struct _Is_ntc<true, _Ty, _Types...>
		: _Cat_base<is_constructible<_Ty, _Types...>::value>
	{	// true if is_constructible and nothrow
	static const bool value = _NOEXCEPT_OP(_Ty(_STD declval<_Types>()...));
	};

 #if __EDG__	/* compiler test */
template<class _Ty,
	class... _Types>
	struct is_nothrow_constructible
		: _Is_ntc<is_constructible<_Ty, _Types...>::value
			&& (!has_virtual_destructor<_Ty>::value
				|| 1 <= sizeof...(_Types)),
			_Ty, _Types...>
	{	// determine whether _Ty is nothrow constructible
	};

 #else /* __EDG__ */
template<class _Ty,
	class... _Types>
	struct is_nothrow_constructible
		: _Is_ntc<is_constructible<_Ty, _Types...>::value,
			_Ty, _Types...>
	{	// determine whether _Ty is nothrow constructible
	};
 #endif /* __EDG__ */

template<class _Ty,
	size_t _Nx>
	struct is_nothrow_constructible<_Ty[_Nx]>
		: is_nothrow_constructible<_Ty>
	{	// true if array element is constructible
	};

	// TEMPLATE CLASS is_nothrow_copy_constructible
template<bool,
	class _Ty>
	struct _Is_ntcc
		: false_type
	{	// here if void
	};

template<class _Ty>
	struct _Is_ntcc<true, _Ty>
		: is_nothrow_constructible<_Ty, const _Ty&>
	{	// here if not void
	};

template<class _Ty>
	struct _Is_ntcc<true, _Ty&>
		: is_nothrow_constructible<_Ty, const _Ty&>
	{	// here if reference and not void
	};

template<class _Ty>
	struct is_nothrow_copy_constructible
		: _Is_ntcc<!is_void<_Ty>::value, _Ty>
	{	// determine whether _Ty is nothrow copy constructible
	};

template<class _Ty,
	size_t _Nx>
	struct is_nothrow_copy_constructible<_Ty[_Nx]>
		: false_type
	{	// false if array
	};

	// TEMPLATE CLASS is_nothrow_default_constructible
template<bool,
	class _Ty>
	struct _Is_ntdc
		: false_type
	{	// false by default
	};

template<class _Ty>
	struct _Is_ntdc<true, _Ty>
		: _Cat_base<_NOTHROW_TEST(_Ty())>
	{	// true if default constructible and nothrow
	};

template<class _Ty>
	struct is_nothrow_default_constructible
		: _Is_ntdc<is_default_constructible<_Ty>::value
			&& !has_virtual_destructor<_Ty>::value, _Ty>
	{	// determine whether _Ty is nothrow default constructible
	};

template<class _Ty,
	size_t _Nx>
	struct is_nothrow_default_constructible<_Ty[_Nx]>
		: is_nothrow_default_constructible<_Ty>
	{	// true if array element is nothrow default constructible
	};

	// TEMPLATE CLASS is_nothrow_move_constructible
template<bool,
	class _Ty>
	struct _Is_ntmc
		: false_type
	{	// here if void
	};

template<class _Ty>
	struct _Is_ntmc<true, _Ty>
		: is_nothrow_constructible<_Ty, _Ty&&>
	{	// here if not void
	};

template<class _Ty>
	struct _Is_ntmc<true, _Ty&>
		: is_nothrow_constructible<_Ty, _Ty&&>
	{	// here if reference and not void
	};

template<class _Ty>
	struct is_nothrow_move_constructible
		: _Is_ntmc<!is_void<_Ty>::value, _Ty>
	{	// determine whether _Ty is nothrow move constructible
	};

template<class _Ty,
	size_t _Nx>
	struct is_nothrow_move_constructible<_Ty[_Nx]>
		: false_type
	{	// false if array
	};

	// TEMPLATE CLASS is_nothrow_assignable
template<bool,
	class _To,
	class _From>
	struct _Is_nta
		: false_type
	{	// false by default
	};

template<class _To,
	class _From>
	struct _Is_nta<true, _To, _From>
		: _Cat_base<
		_NOTHROW_TEST(_STD declval<_To>() = _STD declval<_From>())>
	{	// true if assignable and nothrow
	};

template<class _To,
	class _From>
	struct is_nothrow_assignable
		: _Is_nta<is_assignable<_To, _From>::value, _To, _From>
	{	// determine whether _To = _From is nothrow assignable
	};

	// TEMPLATE CLASS is_nothrow_copy_assignable
template<bool,
	class _Ty>
	struct _Is_ntca
		: false_type
	{	// here if void
	};

template<class _Ty>
	struct _Is_ntca<false, _Ty>
		: is_nothrow_assignable<_Ty&, const _Ty&>
	{	// here if not void
	};

template<class _Ty>
	struct is_nothrow_copy_assignable
		: _Is_ntca<is_void<_Ty>::value, _Ty>
	{	// determine whether _Ty is nothrow copy assignable
	};

	// TEMPLATE CLASS is_nothrow_move_assignable
template<bool,
	class _Ty>
	struct _Is_ntma
		: false_type
	{	// here if void
	};

template<class _Ty>
	struct _Is_ntma<false, _Ty>
		: is_nothrow_assignable<_Ty&, _Ty&&>
	{	// here if not void
	};

template<class _Ty>
	struct is_nothrow_move_assignable
		: _Is_ntma<is_void<_Ty>::value, _Ty>
	{	// determine whether _Ty is nothrow move assignable
	};

	// TEMPLATE CLASS is_nothrow_destructible
template<bool,
	class _Ty>
	struct _Is_ntd
		: false_type
	{	// false by default
	};

template<class _Ty>
	struct _Is_ntd<true, _Ty>
		: _Cat_base<_NOTHROW_TEST(_STD declval<_Ty>().~_Ty())>
	{	// true if destructible and nothrow
	};

template<class _Ty>
	struct decay;

template<class _Ty>
	struct is_nothrow_destructible
		: _Is_ntd<is_destructible<typename decay<_Ty>::type>::value,
			typename decay<_Ty>::type>
	{	// determine whether _Ty is destructible
	};

	// TEMPLATE CLASS add_reference -- retained
template<class _Ty>
	struct add_reference
	{	// add reference
	typedef typename remove_reference<_Ty>::type& type;
	};

#define _ADD_REFERENCE_VOID(CV_OPT) \
template<> \
	struct add_reference<CV_OPT void> \
	{	/* add reference */ \
	typedef CV_OPT void type; \
	};

_CLASS_DEFINE_CV(_ADD_REFERENCE_VOID)
#undef _ADD_REFERENCE_VOID

	// TEMPLATE CLASS has_copy_constructor -- retained
template<class _Ty>
	struct has_copy_constructor
		: is_copy_constructible<_Ty>::type
	{	// determine whether _Ty has a copy constructor
	};

	// TEMPLATE CLASS has_default_constructor -- retained
template<class _Ty>
	struct has_default_constructor
		: is_default_constructible<_Ty>::type
	{	// determine whether _Ty has a default constructor
	};

	// TEMPLATE CLASS has_move_constructor -- retained
template<class _Ty>
	struct has_move_constructor
		: is_move_constructible<_Ty>::type
	{	// determine whether _Ty has a move constructor
	};

	// TEMPLATE CLASS has_copy_assign -- retained
template<class _Ty>
	struct has_copy_assign
		: is_copy_assignable<_Ty>::type
	{	// determine whether _Ty has a copy assignment operator
	};

	// TEMPLATE CLASS has_move_assign -- retained
template<class _Ty>
	struct has_move_assign
		: is_move_assignable<_Ty>::type
	{	// determine whether _Ty has a move assignment operator
	};

	// TEMPLATE CLASS has_trivial_copy_constructor -- retained
template<class _Ty>
	struct has_trivial_copy_constructor
		: is_trivially_copy_constructible<_Ty>::type
	{	// determine whether _Ty has a trivial copy constructor
	};

	// TEMPLATE CLASS has_trivial_default_constructor -- retained
template<class _Ty>
	struct has_trivial_default_constructor
		: is_trivially_default_constructible<_Ty>::type
	{	// determine whether _Ty has a trivial constructor
	};

	// TEMPLATE CLASS has_trivial_move_constructor -- retained
template<class _Ty>
	struct has_trivial_move_constructor
		: is_trivially_move_constructible<_Ty>::type
	{	// determine whether _Ty has a trivial move constructor
	};

	// TEMPLATE CLASS has_trivial_copy_assign -- retained
template<class _Ty>
	struct has_trivial_copy_assign
		: is_trivially_copy_assignable<_Ty>::type
	{	// determine whether _Ty has a trivial copy assignment operator
	};

	// TEMPLATE CLASS has_trivial_move_assign -- retained
template<class _Ty>
	struct has_trivial_move_assign
		: is_trivially_move_assignable<_Ty>::type
	{	// determine whether _Ty has a trivial move assignment operator
	};

	// TEMPLATE CLASS has_nothrow_copy_constructor -- retained
template<class _Ty>
	struct has_nothrow_copy_constructor
		: is_nothrow_copy_constructible<_Ty>
	{	// determine whether _Ty has a nothrow copy constructor
	};

	// TEMPLATE CLASS has_nothrow_default_constructor -- retained
template<class _Ty>
	struct has_nothrow_default_constructor
		: is_nothrow_default_constructible<_Ty>::type
	{	// determine whether _Ty has a nothrow default constructor
	};

	// TEMPLATE CLASS has_nothrow_move_constructor -- retained
template<class _Ty>
	struct has_nothrow_move_constructor
		: is_nothrow_move_constructible<_Ty>::type
	{	// determine whether _Ty has a nothrow move constructor
	};

	// TEMPLATE CLASS has_nothrow_copy_assign -- retained
template<class _Ty>
	struct has_nothrow_copy_assign
		: is_nothrow_copy_assignable<_Ty>::type
	{	// determine whether _Ty has a nothrow copy assignment operator
	};

	// TEMPLATE CLASS has_nothrow_move_assign -- retained
template<class _Ty>
	struct has_nothrow_move_assign
		: is_nothrow_move_assignable<_Ty>::type
	{	// determine whether _Ty has a nothrow move assignment operator
	};

	// TEMPLATE CLASS has_trivial_constructor -- retained
template<class _Ty>
	struct has_trivial_constructor
		_HAS_TRIVIAL_CONSTRUCTOR(_Ty)
	{	// determine whether _Ty has a trivial default constructor
	};

	// TEMPLATE CLASS has_trivial_copy -- retained
template<class _Ty>
	struct has_trivial_copy
		_HAS_TRIVIAL_COPY(_Ty)
	{	// determine whether _Ty has a trivial copy constructor
	};

	// TEMPLATE CLASS has_trivial_assign -- retained
template<class _Ty>
	struct has_trivial_assign
		_HAS_TRIVIAL_ASSIGN(_Ty)
	{	// determine whether _Ty has a trivial assignment operator
	};

	// TEMPLATE CLASS has_trivial_destructor -- retained
template<class _Ty>
	struct has_trivial_destructor
		_HAS_TRIVIAL_DESTRUCTOR(_Ty)
	{	// determine whether _Ty has a trivial destructor
	};

	// TEMPLATE CLASS has_nothrow_constructor -- retained
template<class _Ty>
	struct has_nothrow_constructor
		: is_nothrow_constructible<_Ty>
	{	// determine whether _Ty has a nothrow default constructor
	};

	// TEMPLATE CLASS has_nothrow_copy -- retained
template<class _Ty>
	struct has_nothrow_copy
		: is_nothrow_copy_constructible<_Ty>
	{	// determine whether _Ty has a nothrow copy constructor
	};

	// TEMPLATE CLASS has_nothrow_assign -- retained
template<class _Ty>
	struct has_nothrow_assign
		: is_nothrow_assignable<_Ty, _Ty>
	{	// determine whether _Ty has a nothrow assignment operator
	};

	// TEMPLATE CLASS is_signed
template<class _Ty,
	bool = is_integral<_Ty>::value>
	struct _Sign_base
	{	// determine whether integral _Ty is a signed or unsigned type
	typedef typename remove_cv<_Ty>::type _Uty;
	typedef _Cat_base<_Uty(-1) < _Uty(0)> _Signed;
	typedef _Cat_base<_Uty(0) < _Uty(-1)> _Unsigned;
	};

template<class _Ty>
	struct _Sign_base<_Ty, false>
	{	// floating-point _Ty is signed
		// non-arithmetic _Ty is neither signed nor unsigned
	typedef is_floating_point<_Ty> _Signed;
	typedef false_type _Unsigned;
	};

template<class _Ty>
	struct is_signed
		: _Sign_base<_Ty>::_Signed
	{	// determine whether _Ty is a signed type
	};

	// TEMPLATE CLASS is_unsigned
template<class _Ty>
	struct is_unsigned
		: _Sign_base<_Ty>::_Unsigned
	{	// determine whether _Ty is an unsigned type
	};

	// TEMPLATE CLASS _Change_sign
template<class _Ty>
	struct _Change_sign
	{	// signed/unsigned partners to _Ty
	_Change_sign()
		{	// check asserts
	_STATIC_ASSERT2(
		((is_integral<_Ty>::value || is_enum<_Ty>::value)
			&& !is_same<_Ty, bool>::value),
		"make_signed<T>/make_unsigned<T> require that T shall be a (possibly "
		"cv-qualified) integral type or enumeration but not a bool type.");
		}

	typedef
		typename _If<is_same<_Ty, signed char>::value
			|| is_same<_Ty, unsigned char     >::value, signed char,
		typename _If<is_same<_Ty, short       >::value
			|| is_same<_Ty, unsigned short    >::value, short,
		typename _If<is_same<_Ty, int         >::value
			|| is_same<_Ty, unsigned int      >::value, int,
		typename _If<is_same<_Ty, long        >::value
			|| is_same<_Ty, unsigned long     >::value, long,
		typename _If<is_same<_Ty, long long   >::value
			|| is_same<_Ty, unsigned long long>::value, long long,
		typename _If<sizeof (_Ty) == sizeof (signed char), signed char,
		typename _If<sizeof (_Ty) == sizeof (short      ), short,
		typename _If<sizeof (_Ty) == sizeof (int        ), int,
		typename _If<sizeof (_Ty) == sizeof (long       ), long,
			long long
		>::type>::type>::type>::type>::type>::type>::type>::type>::type
			_Signed;

	typedef
		typename _If<is_same<_Signed, signed char>::value, unsigned char,
		typename _If<is_same<_Signed, short      >::value, unsigned short,
		typename _If<is_same<_Signed, int        >::value, unsigned int,
		typename _If<is_same<_Signed, long       >::value, unsigned long,
			unsigned long long
		>::type>::type>::type>::type
			_Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const _Ty>
	{	// signed/unsigned partners to _Ty
	typedef const typename _Change_sign<_Ty>::_Signed _Signed;
	typedef const typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

template<class _Ty>
	struct _Change_sign<volatile _Ty>
	{	// signed/unsigned partners to _Ty
	typedef volatile typename _Change_sign<_Ty>::_Signed _Signed;
	typedef volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const volatile _Ty>
	{	// signed/unsigned partners to _Ty
	typedef const volatile typename _Change_sign<_Ty>::_Signed _Signed;
	typedef const volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

	// TEMPLATE CLASS make_signed
template<class _Ty>
	struct make_signed
	{	// signed partner to _Ty
	typedef typename _Change_sign<_Ty>::_Signed type;
	};

	// TEMPLATE CLASS make_unsigned
template<class _Ty>
	struct make_unsigned
	{	// unsigned partner to _Ty
	typedef typename _Change_sign<_Ty>::_Unsigned type;
	};

#if !defined(__CODEGEARC__)
	// TEMPLATE CLASS alignment_of
 #ifndef _ALIGN_OF
template<class _Ty>
	struct _Get_align
	{	// struct used to determine alignment of _Ty
	_Ty _Elt0;
	char _Elt1;
	_Ty _Elt2;

	_Get_align();	// to quiet diagnostics
	~_Get_align() _NOEXCEPT;	// to quiet diagnostics
	};

#define _ALIGN_OF(_Ty) (sizeof (_Get_align<_Ty>) - 2 * sizeof (_Ty))
 #endif /* _ALIGN_OF */

template<class _Ty>
	struct alignment_of
		: integral_constant<size_t, _ALIGN_OF(_Ty)>
	{	// determine alignment of _Ty
	};
#else
template<class _Ty>
	struct alignment_of
		: integral_constant<size_t, alignof(_Ty)>
	{	// determine alignment of _Ty
	};
#endif

	// TEMPLATE CLASS aligned_storage
#define _FITS(_Ty)	_Align <= alignment_of<_Ty>::value
#define _NEXT_ALIGN(_Ty)	\
	typedef typename _Aligned<_Len, _Align, _Ty, _FITS(_Ty)>::type type

template<class _Ty,
	size_t _Len>
	union _Align_type
	{	// union with size _Len bytes and alignment of _Ty
	_Ty _Val;
	char _Pad[_Len];
	};

template<size_t _Len,
	size_t _Align,
	class _Ty,
	bool _Ok>
	struct _Aligned;

template<size_t _Len,
	size_t _Align,
	class _Ty>
	struct _Aligned<_Len, _Align, _Ty, true>
	{	// define type with size _Len and alignment _Ty
	typedef _Align_type<_Ty, _Len> type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, double, false>
	{	// define type with size _Len and alignment _Ty
	typedef _Align_type<max_align_t, _Len> type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, int, false>
	{	// define type with size _Len and alignment _Ty
	_NEXT_ALIGN(double);
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, short, false>
	{	// define type with size _Len and alignment _Ty
	_NEXT_ALIGN(int);
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, char, false>
	{	// define type with size _Len and alignment _Ty
	_NEXT_ALIGN(short);
	};

template<size_t _Len,
	size_t _Align =
		_Len < alignment_of<short>::value
			? alignment_of<char>::value
		: _Len < alignment_of<int>::value
			? alignment_of<short>::value
		: _Len < alignment_of<double>::value
			? alignment_of<int>::value
		: _Len < alignment_of<max_align_t>::value
			? alignment_of<double>::value
		: alignment_of<max_align_t>::value>
	struct aligned_storage
	{	// define type with size _Len and alignment _Align
	typedef typename _Aligned<_Len, _Align, char, _FITS(char)>::type type;
	};

#undef _FITS
#undef _NEXT_ALIGN

 #if _HAS_CPP11 || 1	/* useful with C++03 */
	// TEMPLATE CLASS aligned_union
template<size_t... _Vals>
	struct _Maximum;

template<>
	struct _Maximum<>
	{	// maximum of nothing is 0
	static const size_t value = 0;
	};

template<size_t _Val>
	struct _Maximum<_Val>
	{	// maximum of _Val is _Val
	static const size_t value = _Val;
	};

template<size_t _First,
	size_t _Second,
	size_t... _Rest>
	struct _Maximum<_First, _Second, _Rest...>
		: _Maximum<(_First < _Second ? _Second : _First), _Rest...>
	{	// find maximum value in _First, _Second, _Rest...
	};

template<size_t _Len,
	class... _Types>
	struct aligned_union
	{	// define type with size at least _Len, for storing anything in _Types
	static const size_t _Max_len = _Maximum<
		_Len, sizeof(_Types)...>::value;	// NOT sizeof...(_Types)
	static const size_t alignment_value = _Maximum<
		alignment_of<_Types>::value...>::value;
	typedef typename aligned_storage<_Max_len, alignment_value>::type type;
	};

	// TEMPLATE CLASS underlying_type
template<class _Ty>
	struct underlying_type
	{	// determine type underlying type for enum
	typedef _UNDERLYING_TYPE(_Ty) type;
	};
 #endif /* _HAS_CPP11 */

	// TEMPLATE CLASS rank
template<class _Ty>
	struct rank
		: integral_constant<size_t, 0>
	{	// determine number of dimensions of array _Ty
	};

template<class _Ty,
	size_t _Ix>
	struct rank<_Ty[_Ix]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	// determine number of dimensions of array _Ty
	};

template<class _Ty>
	struct rank<_Ty[]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	// determine number of dimensions of array _Ty
	};

	// TEMPLATE CLASS extent
template<class _Ty, unsigned int _Nx>
	struct _Extent
		: integral_constant<size_t, 0>
	{	// determine extent of dimension _Nx of array _Ty
	};

template<class _Ty,
	size_t _Ix>
	struct _Extent<_Ty[_Ix], 0>
		: integral_constant<size_t, _Ix>
	{	// determine extent of dimension _Nx of array _Ty
	};

template<class _Ty,
	unsigned int _Nx,
	size_t _Ix>
	struct _Extent<_Ty[_Ix], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	// determine extent of dimension _Nx of array _Ty
	};

template<class _Ty, unsigned int _Nx>
	struct _Extent<_Ty[], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	// determine extent of dimension _Nx of array _Ty
	};

template<class _Ty, unsigned int _Nx = 0>
	struct extent
		: _Extent<_Ty, _Nx>
	{	// determine extent of dimension _Nx of array _Ty
	};

	// TEMPLATE CLASS decay
template<class _Ty>
	struct decay
	{	// determines decayed version of _Ty
	typedef typename remove_reference<_Ty>::type _Ty1;

	typedef typename _If<is_array<_Ty1>::value,
		typename remove_extent<_Ty1>::type *,
		typename _If<is_function<_Ty1>::value,
			typename add_pointer<_Ty1>::type,
			typename remove_cv<_Ty1>::type>::type>::type type;
	};

	// TEMPLATE CLASS is_base_of
template<class _Base,
	class _Der>
	struct is_base_of
		_IS_BASE_OF(_Base, _Der)
	{	// determine whether _Base is a base of or the same as _Der
	};

 #if _HAS_TEMPLATE_ALIAS
template<class _Ty>
	using decay_t = typename decay<_Ty>::type;

template<class...>
	using void_t = void;	// defined in C++17, but useful in _Alloc_destroy
 #endif /* _HAS_TEMPLATE_ALIAS */

 #if _HAS_TR1_IMPORTS
namespace tr1 {	// TR1 additions
using _STD add_const;
using _STD add_cv;
using _STD add_pointer;
using _STD add_volatile;
using _STD aligned_storage;
using _STD alignment_of;
using _STD conditional;
using _STD decay;
using _STD enable_if;
using _STD extent;
using _STD false_type;
using _STD has_virtual_destructor;
using _STD integral_constant;
using _STD is_abstract;
using _STD is_arithmetic;
using _STD is_array;
using _STD is_base_of;
using _STD is_class;
using _STD is_compound;
using _STD is_const;
using _STD is_convertible;
using _STD is_empty;
using _STD is_enum;
using _STD is_floating_point;
using _STD is_function;
using _STD is_fundamental;
using _STD is_integral;
using _STD is_member_function_pointer;
using _STD is_member_object_pointer;
using _STD is_member_pointer;
using _STD is_object;
using _STD is_pod;
using _STD is_pointer;
using _STD is_polymorphic;
using _STD is_reference;
using _STD is_same;
using _STD is_scalar;
using _STD is_signed;
using _STD is_union;
using _STD is_unsigned;
using _STD is_void;
using _STD is_volatile;
using _STD make_signed;
using _STD make_unsigned;
using _STD rank;
using _STD remove_all_extents;
using _STD remove_const;
using _STD remove_cv;
using _STD remove_extent;
using _STD remove_pointer;
using _STD remove_reference;
using _STD remove_volatile;
using _STD true_type;

using _STD add_reference;	// retained
using _STD has_nothrow_assign;	// retained
using _STD has_nothrow_constructor;	// retained
using _STD has_nothrow_copy;	// retained
using _STD has_trivial_assign;	// retained
using _STD has_trivial_constructor;	// retained
using _STD has_trivial_copy;	// retained
using _STD has_trivial_destructor;	// retained
	}	// namespace tr1
 #endif /* _HAS_TR1_IMPORTS */

 #if _HAS_CPP11
		// TEMPLATE STRUCT common_type
template<class _Ty>
	struct _Common_arg
	{	// non void, non array
	static const bool value = 0 < sizeof(_Ty);
	};

template<class _Ty>
	struct _Common_arg<_Ty[]>
	{	// array
	static const bool value = true;
	};

template<>
	struct _Common_arg<void>
	{	// void
	static const bool value = true;
	};

template<>
	struct _Common_arg<const void>
	{	// const void
	static const bool value = true;
	};

template<>
	struct _Common_arg<volatile void>
	{	// volatile void
	static const bool value = true;
	};

template<>
	struct _Common_arg<const volatile void>
	{	// const volatile void
	static const bool value = true;
	};

template<class _Ty,
	bool>
	struct _Common_type1
	{	// no type
	static const bool _Is_valid = false;
	};

template<class _Ty>
	struct _Common_type1<_Ty, true>
	{	// valid type
	static const bool _Is_valid = true;
	typedef typename decay<_Ty>::type type;
	};

template<class... _Ty>
	struct common_type;

template<class _Ty>
	struct common_type<_Ty>
	: _Common_type1<_Ty, _Common_arg<_Ty>::value>
	{	// type
	};

template<class _Ty1,
	class _Ty2,
	bool>
	struct _Common_type2
	{	// no type
	};

template<class _Ty1>
	struct _Common_type2<_Ty1, _Ty1, true>
	{	// no type
	typedef _Ty1 type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Common_type2<_Ty1, _Ty2, true>
	{	// valid types
	typedef decltype(false
		? declval<_Ty1>()
		: declval<_Ty2>()) type;
	};

template<class _Ty1,
	class _Ty2>
	struct common_type<_Ty1, _Ty2>
	: _Common_type2<_Ty1, _Ty2,
		common_type<_Ty1>::_Is_valid && common_type<_Ty2>::_Is_valid>
	{	// type is common type of _Ty1 and _Ty2 for two arguments
	};

template<class _Ty1,
	class _Ty2,
	class... _Ty>
	struct common_type<_Ty1, _Ty2, _Ty...>
	{	// type is defined recursively for more than two arguments
	typedef typename common_type<
		typename common_type<_Ty1, _Ty2>::type,
		_Ty...
		>::type type;
	};
 #endif /* _HAS_CPP11 */

	// TEMPLATE STRUCT integer_sequence
template<class _Ty,
	_Ty... _Vals>
	struct integer_sequence
	{	// sequence of integer parameters
	_STATIC_ASSERT2(is_integral<_Ty>::value,
		"integer_sequence<T, I...> requires T to be an integral type.");

	typedef integer_sequence<_Ty, _Vals...> type;
	typedef _Ty value_type;

	static _CONST_FUN size_t size() _NOEXCEPT
		{	// get length of parameter list
		return (sizeof...(_Vals));
		}
	};

	// ALIAS TEMPLATE make_integer_sequence
template<bool _Negative,
	bool _Zero,
	class _Int_con,
	class _Int_seq>
	struct _Make_seq
	{	// explodes gracefully below 0
	_STATIC_ASSERT2(!_Negative,
		"make_integer_sequence<T, N> requires N to be non-negative.");
	};

template<class _Ty,
	_Ty... _Vals>
	struct _Make_seq<false, true,
		integral_constant<_Ty, 0>,
		integer_sequence<_Ty, _Vals...> >
		: integer_sequence<_Ty, _Vals...>
	{	// ends recursion at 0
	};

template<class _Ty,
	_Ty _Ix,
	_Ty... _Vals>
	struct _Make_seq<false, false,
		integral_constant<_Ty, _Ix>,
		integer_sequence<_Ty, _Vals...> >
		: _Make_seq<false, _Ix == 1,
			integral_constant<_Ty, _Ix - 1>,
			integer_sequence<_Ty, _Ix - 1, _Vals...> >
	{	// counts down to 0
	};

 #if _HAS_TEMPLATE_ALIAS
template<class _Ty,
	_Ty _Size>
	using make_integer_sequence = typename _Make_seq<_Size < 0, _Size == 0,
		integral_constant<_Ty, _Size>, integer_sequence<_Ty> >::type;

template<size_t... _Vals>
	using index_sequence = integer_sequence<size_t, _Vals...>;

template<size_t _Size>
	using make_index_sequence = make_integer_sequence<size_t, _Size>;

template<class... _Types>
	using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

 #else /* _HAS_TEMPLATE_ALIAS */
template<class _Ty,
	_Ty _Size>
	struct make_integer_sequence
		: _Make_seq<_Size < 0, _Size == 0,
			integral_constant<_Ty, _Size>,
			integer_sequence<_Ty> >
	{	// {0, 1 ...} of type _Ty
	};

template<size_t... _Vals>
	struct index_sequence
		: integer_sequence<size_t, _Vals...>
	{	// {0, 1 ...} of type size_t
	};

template<size_t _Size>
	struct make_index_sequence
		: make_integer_sequence<size_t, _Size>
	{	// sequence of _Size size_t parameters
	};

template<class... _Ty>
	struct index_sequence_for
		: make_index_sequence<sizeof...(_Ty)>
	{	// sequence of sizeof...(_Ty) size_t parameters
	};
 #endif /* _HAS_TEMPLATE_ALIAS */

	// TEMPLATE CLASS identity
template<class _Ty>
	struct identity
	{	// map _Ty to type unchanged
	typedef _Ty type;

	const _Ty& operator()(const _Ty& _Left) const
		{	// apply identity operator to operand
		return (_Left);
		}
	};

	// TEMPLATE FUNCTION forward
template<class _Ty> inline
	_CONST_FUN _Ty&& forward(
		remove_reference_t<_Ty>& _Arg) _NOEXCEPT
	{	// forward an lvalue as either an lvalue or an rvalue
	return (static_cast<_Ty&&>(_Arg));
	}

template<class _Ty> inline
	_CONST_FUN _Ty&& forward(
		remove_reference_t<_Ty>&& _Arg) _NOEXCEPT
	{	// forward an rvalue as an rvalue
	_STATIC_ASSERT2(!is_lvalue_reference<_Ty>::value, "bad forward call");
	return (static_cast<_Ty&&>(_Arg));
	}

	// TEMPLATE FUNCTION move
template<class _Ty> inline
	_CONST_FUN remove_reference_t<_Ty>&&
		move(_Ty&& _Arg) _NOEXCEPT
	{	// forward _Arg as movable
	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));
	}

		// TEMPLATE FUNCTION _Move
template<class _Ty> inline
	_CONST_FUN typename remove_reference<_Ty>::type&&
		_Move(_Ty&& _Arg) _NOEXCEPT
	{	// forward _Arg as movable
	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));
	}

		// TEMPLATE FUNCTION move_if_noexcept
template<class _Ty> inline
	_CONST_FUN typename _If<!is_nothrow_move_constructible<_Ty>::value
		&& is_copy_constructible<_Ty>::value,
			const _Ty&, _Ty&&>::type
	move_if_noexcept(_Ty& _Arg) _NOEXCEPT
	{	// forward _Arg as movable, sometimes
	return (_STD move(_Arg));
	}

	// TEMPLATE FUNCTION _Decay_copy
template<class _Ty> inline
	decay_t<_Ty> _Decay_copy(_Ty&& _Arg)
	{	// forward _Arg as value of decayed type
	return (_STD forward<_Ty>(_Arg));
	}

	// TEMPLATE STRUCT _Param_tester
template<class...>
	struct _Param_tester
	{	// test if parameters are valid
	typedef void type;
	};

	// TEMPLATE FUNCTION invoke
#define _CALL_EXPR (_STD forward<_Ty1>(_Arg1).*_Pmf)( \
			_STD forward<_Types2>(_Args2)...)
struct _Invoker_pmf_object
	{	// INVOKE a pointer to member function on an object
	template<class _Decayed,
		class _Ty1,
		class... _Types2>
		static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
			_NOEXCEPT_OP(noexcept(_CALL_EXPR))
		-> decltype(_CALL_EXPR)
		{	// INVOKE a pointer to member function on an object
		return (_CALL_EXPR);
		}
	};
#undef _CALL_EXPR

#define _CALL_EXPR ((*_STD forward<_Ty1>(_Arg1)).*_Pmf)( \
			_STD forward<_Types2>(_Args2)...)
struct _Invoker_pmf_pointer
	{	// INVOKE a pointer to member function on a [smart] pointer
	template<class _Decayed,
		class _Ty1,
		class... _Types2>
		static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
			_NOEXCEPT_OP(noexcept(_CALL_EXPR))
		-> decltype(_CALL_EXPR)
		{	// INVOKE a pointer to member function on a [smart] pointer
		return (_CALL_EXPR);
		}
	};
#undef _CALL_EXPR

#define _CALL_EXPR _STD forward<_Ty1>(_Arg1).*_Pmd
struct _Invoker_pmd_object
	{	// INVOKE a pointer to member data on an object
	template<class _Decayed,
		class _Ty1>
		static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
			_NOEXCEPT_OP(noexcept(_CALL_EXPR))
		-> decltype(_CALL_EXPR)
		{	// INVOKE a pointer to member data on an object
		return (_CALL_EXPR);
		}
	};
#undef _CALL_EXPR

#define _CALL_EXPR (*_STD forward<_Ty1>(_Arg1)).*_Pmd
struct _Invoker_pmd_pointer
	{	// INVOKE a pointer to member data on a [smart] pointer
	template<class _Decayed,
		class _Ty1>
		static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
			_NOEXCEPT_OP(noexcept(_CALL_EXPR))
		-> decltype(_CALL_EXPR)
		{	// INVOKE a pointer to member data on a [smart] pointer
		return (_CALL_EXPR);
		}
	};
#undef _CALL_EXPR

#define _CALL_EXPR _STD forward<_Callable>(_Obj)( \
			_STD forward<_Types>(_Args)...)
struct _Invoker_functor
	{	// INVOKE a function object
	template<class _Callable,
		class... _Types>
		static auto _Call(_Callable&& _Obj, _Types&&... _Args)
			_NOEXCEPT_OP(noexcept(_CALL_EXPR))
		-> decltype(_CALL_EXPR)
		{	// INVOKE a function object
		return (_CALL_EXPR);
		}
	};
#undef _CALL_EXPR

template<class _Callable,
	class _Ty1,
	class _Decayed = decay_t<_Callable>,
	bool _Is_pmf = is_member_function_pointer<_Decayed>::value,
	bool _Is_pmd = is_member_object_pointer<_Decayed>::value>
	struct _Invoker1;

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, true, false>
		: _If<is_base_of<
			typename _Is_memfunptr<_Decayed>::_Class_type,
			decay_t<_Ty1> >::value,
		_Invoker_pmf_object,
		_Invoker_pmf_pointer>::type
	{	// pointer to member function
	};

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, false, true>
		: _If<is_base_of<
			typename _Is_member_object_pointer<_Decayed>::_Class_type,
			decay_t<_Ty1> >::value,
		_Invoker_pmd_object,
		_Invoker_pmd_pointer>::type
	{	// pointer to member data
	};

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, false, false>
		: _Invoker_functor
	{	// function object
	};

template<class _Callable,
	class... _Types>
	struct _Invoker;

template<class _Callable>
	struct _Invoker<_Callable>
		: _Invoker_functor
	{	// zero arguments
	};

template<class _Callable,
	class _Ty1,
	class... _Types2>
	struct _Invoker<_Callable, _Ty1, _Types2...>
		: _Invoker1<_Callable, _Ty1>
	{	// one or more arguments
	};

#define _CALL_EXPR _Invoker<_Callable, _Types...>::_Call( \
		_STD forward<_Callable>(_Obj), _STD forward<_Types>(_Args)...)
template<class _Callable,
	class... _Types> inline
	auto invoke(_Callable&& _Obj, _Types&&... _Args)
		_NOEXCEPT_OP(noexcept(_CALL_EXPR))
	-> decltype(_CALL_EXPR)
	{	// INVOKE a callable object
	return (_CALL_EXPR);
	}
#undef _CALL_EXPR

template<class _Rx,
	bool = is_void<_Rx>::value>
	struct _Forced
	{	// tag to give INVOKE an explicit return type
	};

struct _Unforced
	{	// tag to distinguish bind() from bind<R>()
	};

template<class _Cv_void,
	class... _Valtys> inline
	void _Invoke_ret(_Forced<_Cv_void, true>, _Valtys&&... _Vals)
	{	// INVOKE, "implicitly" converted to void
	_STD invoke(_STD forward<_Valtys>(_Vals)...);
	}

template<class _Rx,
	class... _Valtys> inline
	_Rx _Invoke_ret(_Forced<_Rx, false>, _Valtys&&... _Vals)
	{	// INVOKE, implicitly converted to _Rx
	return (_STD invoke(_STD forward<_Valtys>(_Vals)...));
	}

template<class... _Valtys> inline
	auto _Invoke_ret(_Forced<_Unforced, false>, _Valtys&&... _Vals)
	-> decltype(_STD invoke(_STD forward<_Valtys>(_Vals)...))
	{	// INVOKE, unchanged
	return (_STD invoke(_STD forward<_Valtys>(_Vals)...));
	}

	// TEMPLATE CLASS result_of
template<class _Fty,
	class...>
	struct result_of
	{	// explain usage
	static_assert(_Always_false<_Fty>::value,
		"result_of<CallableType> is invalid; use "
		"result_of<CallableType(zero or more argument types)> instead.");
	};

#define _RESULT_OF(CALL_OPT) \
template<class _Fty, \
	class... _Types> \
	struct result_of<_Fty CALL_OPT (_Types...)> \
	{	/* template to determine result of call operation */ \
	typedef decltype(_STD invoke(_STD declval<_Fty>(), \
		_STD declval<_Types>()...)) type; \
	};

_NON_MEMBER_CALL(_RESULT_OF)
#undef _RESULT_OF

	// TEMPLATE STRUCT _Weak_types
template<class _Ty,
	class = void>
	struct _Weak_result_type
	{	// default definition
	};

template<class _Ty>
	struct _Weak_result_type<_Ty, typename _Param_tester<
		typename _Ty::result_type>::type>
	{	// defined if _Ty::result_type exists
	typedef typename _Ty::result_type result_type;
	};

template<class _Ty,
	class = void>
	struct _Weak_argument_type
		: _Weak_result_type<_Ty>
	{	// default definition
	};

template<class _Ty>
	struct _Weak_argument_type<_Ty, typename _Param_tester<
		typename _Ty::argument_type>::type>
		: _Weak_result_type<_Ty>
	{	// defined if _Ty::argument_type exists
	typedef typename _Ty::argument_type argument_type;
	};

template<class _Ty,
	class = void>
	struct _Weak_binary_args
		: _Weak_argument_type<_Ty>
	{	// default definition
	};

template<class _Ty>
	struct _Weak_binary_args<_Ty, typename _Param_tester<
		typename _Ty::first_argument_type,
		typename _Ty::second_argument_type>::type>
		: _Weak_argument_type<_Ty>
	{	// defined if both types exist
	typedef typename _Ty::first_argument_type first_argument_type;
	typedef typename _Ty::second_argument_type second_argument_type;
	};

template<class _Ty>
	struct _Weak_types
	{	// provide nested types (sometimes)
	typedef _Is_function<typename remove_pointer<_Ty>::type> _Is_f_or_pf;
	typedef _Is_memfunptr<typename remove_cv<_Ty>::type> _Is_pmf;
	typedef typename _If<_Is_f_or_pf::_Bool_type::value, _Is_f_or_pf,
		typename _If<_Is_pmf::_Bool_type::value, _Is_pmf,
		_Weak_binary_args<_Ty> >::type>::type type;
	};

	// TEMPLATE CLASS reference_wrapper
template<class _Ty>
	class reference_wrapper
		: public _Weak_types<_Ty>::type
	{	// stand-in for an assignable reference
public:
	static_assert(is_object<_Ty>::value || is_function<_Ty>::value,
		"reference_wrapper<T> requires T to be an object type "
		"or a function type.");

	typedef _Ty type;

	reference_wrapper(_Ty& _Val) _NOEXCEPT
		: _Ptr(_STD addressof(_Val))
		{	// construct
		}

	operator _Ty&() const _NOEXCEPT
		{	// return reference
		return (*_Ptr);
		}

	_Ty& get() const _NOEXCEPT
		{	// return reference
		return (*_Ptr);
		}

	template<class... _Types>
		auto operator()(_Types&&... _Args) const
		-> decltype(_STD invoke(this->get(), _STD forward<_Types>(_Args)...))
		{	// invoke object/function
		return (_STD invoke(get(), _STD forward<_Types>(_Args)...));
		}

	reference_wrapper(_Ty&&) = delete;

private:
	_Ty *_Ptr;
	};

	// TEMPLATE FUNCTION invoke FOR reference_wrapper
std::false_type _Is_RW_impl(...);
template <class _Ty>
std::true_type _Is_RW_impl(std::reference_wrapper<_Ty>*);

template <class _Ty>
struct _Is_RW
    : decltype(_Is_RW_impl(std::declval<std::remove_reference_t<_Ty>*>()))
    {	// default implementation
    };

#define _CALL_EXPR invoke(_STD forward<_Callable>(_PM), _Obj.get(), _STD forward<_Types>(_Args)...)
template<class _Callable,
	class _RW,
	class... _Types,
	class = enable_if_t<
		is_member_pointer<_Callable>::value
		&& _Is_RW<_RW>::value> > inline
	auto invoke(_Callable&& _PM, _RW&& _Obj,  _Types&&... _Args)
		_NOEXCEPT_OP(noexcept(_CALL_EXPR))
	-> decltype(_CALL_EXPR)
	{	// INVOKE a ponter to member on a reference_wrapper
	return (_CALL_EXPR);
	}

	// TEMPLATE FUNCTIONS ref AND cref
template<class _Ty> inline
	reference_wrapper<_Ty>
		ref(_Ty& _Val) _NOEXCEPT
	{	// create reference_wrapper<_Ty> object
	return (reference_wrapper<_Ty>(_Val));
	}

template<class _Ty>
	void ref(const _Ty&&) = delete;

template<class _Ty> inline
	reference_wrapper<_Ty>
		ref(reference_wrapper<_Ty> _Val) _NOEXCEPT
	{	// create reference_wrapper<_Ty> object
	return (_STD ref(_Val.get()));
	}

template<class _Ty> inline
	reference_wrapper<const _Ty>
		cref(const _Ty& _Val) _NOEXCEPT
	{	// create reference_wrapper<const _Ty> object
	return (reference_wrapper<const _Ty>(_Val));
	}

template<class _Ty>
	void cref(const _Ty&&) = delete;

template<class _Ty> inline
	reference_wrapper<const _Ty>
		cref(reference_wrapper<_Ty> _Val) _NOEXCEPT
	{	// create reference_wrapper<const _Ty> object
	return (_STD cref(_Val.get()));
	}

	// TEMPLATE STRUCT invoke_result
template<class _Void,
	class _Func,
	class... _Types>
	struct _Invoke_result
	{	// empty if not well defined
	};

template<class _Func,
	class... _Types>
	struct _Invoke_result<decltype(void(_STD invoke(_STD declval<_Func>(),
		_STD declval<_Types>()...))), _Func, _Types...>
	{	// define type if well defined
	typedef decltype(_STD invoke(_STD declval<_Func>(),
		_STD declval<_Types>()...)) type;
	};

template<class _Func,
	class... _Types>
	struct invoke_result
		: _Invoke_result<void, _Func, _Types...>
	{	// define type if well defined
	};

	// TEMPLATE CLASS _Unrefwrap
template<class _Ty>
	struct _Unrefwrap_helper
	{	// leave unchanged if not a reference_wrapper
	typedef _Ty type;
	static const bool _Is_refwrap = false;
	};

template<class _Ty>
	struct _Unrefwrap_helper<reference_wrapper<_Ty> >
	{	// make a reference from a reference_wrapper
	typedef _Ty& type;
	static const bool _Is_refwrap = true;
	};

template<class _Ty>
	struct _Unrefwrap
	{	// decay, then unwrap a reference_wrapper
	typedef decay_t<_Ty> _Ty1;
	typedef typename _Unrefwrap_helper<_Ty1>::type type;
	static const bool _Is_refwrap = _Unrefwrap_helper<_Ty1>::_Is_refwrap;
	};

	// TEMPLATE CLASS _Rerefwrap
template<bool _Is_ref,
	class _Ty>
	struct _Rerefwrap
	{	// leave unchanged if not a reference
	static _Ty _Apply(_Ty _Arg)
		{	// leave unchanged
		return (_Arg);
		}
	};

template<class _Ty>
	struct _Rerefwrap<true, _Ty>
	{	// wrap if a reference
	static auto _Apply(_Ty _Arg) -> decltype(_STD ref(_Arg))
		{	// rewrap
		return (_STD ref(_Arg));
		}
	};

 #if _HAS_TR1_IMPORTS
namespace tr1 {	// TR1 additions
using _STD cref;
using _STD ref;
using _STD reference_wrapper;
using _STD result_of;
	}	// namespace tr1
 #endif /* _HAS_TR1_IMPORTS */

template<class _Ty1,
	class _Ty2>
	void swap(_Ty1&, _Ty2&);

 #if _HAS_CPP17
	// TEMPLATE STRUCT conjunction
template<class... _Bases>
	struct conjunction;

template<>
	struct conjunction<>
		: true_type
	{	// empty list is true
	};

template<class _Base>
	struct conjunction<_Base>
		: _Base
	{	// last base in line supplies value
	};

template<class _Base,
	class... _Rest>
	struct conjunction<_Base, _Rest...>
		: integral_constant<bool, conditional<_Base::value == false,
		_Base,
		conjunction<_Rest...> >::type::value>
	{	// last two bases in line
	};

	// TEMPLATE STRUCT disjunction
template<class... _Bases>
	struct disjunction;

template<>
	struct disjunction<>
		: false_type
	{	// empty list is false
	};

template<class _Base>
	struct disjunction<_Base>
		: _Base
	{	// last base in line supplies value
	};

template<class _Base,
	class... _Rest>
	struct disjunction<_Base, _Rest...>
		: integral_constant<bool, conditional<_Base::value == true,
		_Base,
		disjunction<_Rest...> >::type::value>
	{	// last two bases in line
	};

	// TEMPLATE STRUCT negation
template<class _Base>
	struct negation
		: integral_constant<bool, !_Base::value>
	{	// negate type of _Base
	};

	// TEMPLATE CLASS is_callable
template<bool,
	class _Func,
	class _Ret>
	struct _Is_callable
		: false_type
	{	// invalid call expressiom
	};

template<class _Func,
	class... _Types,
	class _Ret>
	struct _Is_callable<true, _Func(_Types...), _Ret>
	{	// tests whether _Ret(_Func(_Types...)) is valid
	template<class _Uret>
		static auto _Fn(int)
			-> decltype(_Ret(_STD invoke(_STD declval<_Func>(),
				_STD declval<_Types>()...)),
				true_type());
	template<class _Uret>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_Ret>(0)) type;
	};

template<class _Func,
	class _Ret = void>
	struct is_callable;

template<class _Func,
	class... _Types,
	class _Ret>
	struct is_callable<_Func(_Types...), _Ret>
		: _Is_callable<is_function<_Func(_Types...)>::value,
			_Func(_Types...), _Ret>::type
	{	// tests whether _Ret(_Func(_Types...)) is valid
	};

	// TEMPLATE CLASS is_nothrow_callable
template<bool,
	class _Func,
	class _Ret>
	struct _Is_nothrow_callable
		: false_type
	{	// invalid call expressiom
	};

template<class _Func,
	class... _Types,
	class _Ret>
	struct _Is_nothrow_callable<true, _Func(_Types...), _Ret>
	{	// tests whether _Ret(_Func(_Types...)) is valid and nothrow
	template<class _Uret>
		static auto _Fn(int)
			-> decltype(_Ret(_STD invoke(_STD declval<_Func>(),
					_STD declval<_Types>()...)),
				_NOTHROW_TEST(_Ret(_Func(_STD declval<_Func>(),
					_STD declval<_Types>())...)),
				true_type());
	template<class _Uret>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_Ret>(0)) type;
	};

template<class _Func,
	class _Ret = void>
	struct is_nothrow_callable;

template<class _Func,
	class... _Types,
	class _Ret>
	struct is_nothrow_callable<_Func(_Types...), _Ret>
		: _Is_nothrow_callable<is_function<_Func(_Types...)>::value,
			_Func(_Types...), _Ret>::type
	{	// tests whether _Ret(_Func(_Types...)) is valid and nothrow
	};

	// TEMPLATE CLASS is_invocable
template <class _T, class = void>
struct _Is_invocable
    : false_type
    {	// invalid invoke expression
    };
template <class _T>
struct _Is_invocable<_T, void_t<typename _T::type> >
    : true_type
    {	// tests whether invoke_result::type exists
    };

template <class _Func, class... _Types>
struct is_invocable
    : _Is_invocable<std::invoke_result<_Func, _Types...> >
	{	// tests whether invoke<_Func, _Types...> is valid
    };
template <class _Func>
   struct is_invocable<_Func, void>
    : _Is_invocable<std::invoke_result<_Func> >
	{	// tests whether invoke<_Func, void> is valid
    };

	// TEMPLATE CLASS is_invocable_r
template <class _Ret, class _T, class = void>
struct _Is_invocable_r
    : false_type
    {	// invalid invoke expression
    };
template <class _Ret, class _T>
struct _Is_invocable_r<_Ret, _T, void_t<typename _T::type> >
    : _If<is_convertible<typename _T::type, _Ret>::value,
    	true_type,
    	false_type>::type
    {	// tests whether invoke_result::type exists and convertible to _Ret
    };

template <class _Ret, class _Func, class... _Types>
struct is_invocable_r
    : _Is_invocable_r<_Ret, std::invoke_result<_Func, _Types...> >
	{	// tests whether invoke<_Func, _Types...> is valid
		// and ionvertible to _Ret
    };
template <class _Ret, class _Func>
struct is_invocable_r<_Ret, _Func, void>
    : _Is_invocable_r<_Ret, std::invoke_result<_Func> >
	{	// tests whether invoke<_Func, void> is valid and convertible to _Ret
    };

	// TEMPLATE CLASS is_nothrow_invocable
template <class _T, class = void>
struct _Is_nothrow_invocable
	{	// invalid invoke expression
	template <class _Func, class... _Types>
	struct _Is_nothrow
		: false_type
		{	// false by default
		};
	};
template <class _T>
struct _Is_nothrow_invocable<_T, void_t<typename _T::type> >
	{	// valid invoke expression
	template <class _Func, class... _Types>
	struct _Is_nothrow
		: _If<noexcept(invoke(declval<_Func>(), declval<_Types>()...)),
			true_type,
			false_type>::type
		{	// tests whether invoke call is nothrow
		};
	};

template <class _Func, class... _Types>
struct is_nothrow_invocable
		: _Is_nothrow_invocable<std::invoke_result<_Func, _Types...> >
			::template _Is_nothrow<_Func, _Types...>
	{	// tests whether invoke<_Func, _Types...> is valid and nothrow
	};
template <class _Func>
struct is_nothrow_invocable<_Func, void>
		: _Is_nothrow_invocable<std::invoke_result<_Func> >
			::template _Is_nothrow<_Func>
	{	// tests whether invoke<_Func, void> is valid and nothrow
	};

	// TEMPLATE CLASS is_nothrow_invocable_r
template <class _T, class = void>
struct _Is_nothrow_invocable_r
	{	// invalid invoke expression
	template <class _Func, class... _Types>
	struct _Is_nothrow
		: false_type
		{	// false by default
		};
	};
template <class _T>
struct _Is_nothrow_invocable_r<_T, void_t<typename _T::type> >
	{	// valid invoke expression
	template <class _Ret, class _Func, class... _Types>
	struct _Is_nothrow
		: _If<noexcept(invoke(declval<_Func>(), declval<_Types>()...))
			&& is_convertible<typename _T::type, _Ret>::value,
			true_type,
			false_type>::type
		{	// tests whether invoke call is nothrow and convertible to _Ret
		};
	};

template <class _Ret, class _Func, class... _Types>
struct is_nothrow_invocable_r
		: _Is_nothrow_invocable_r<std::invoke_result<_Func, _Types...> >
			::template _Is_nothrow<_Ret, _Func, _Types...>
	{	// tests whether invoke<_Func, _Types...> is valid, nothrow,
		// and convertible to _Ret
	};
template <class _Ret, class _Func>
struct is_nothrow_invocable_r<_Ret, _Func, void>
		: _Is_nothrow_invocable_r<std::invoke_result<_Func> >
			::template _Is_nothrow<_Ret, _Func>
	{	// tests whether invoke<_Func, viud> is valid, nothrow,
		// and convertible to _Ret
	};
 #endif /* _HAS_CPP17 */

	// TEMPLATE CLASS is_swappable_with
template<bool,
	class _Ty1,
	class _Ty2>
	struct _Is_swappable_with
		: false_type
	{	// invalid swap expressiom
	};

template<class _Ty1,
	class _Ty2>
	struct _Is_swappable_with<true, _Ty1, _Ty2>
	{	// tests whether _Ty1 is swappable with _Ty2
	typedef typename add_lvalue_reference<_Ty1>::type _Rty1;
	typedef typename add_lvalue_reference<_Ty2>::type _Rty2;

	template<class _Uty>
		static auto _Fn(int)
			-> decltype(_Cat_base<(_NOEXCEPT_OP(_NOEXCEPT_OP(
				_STD swap(_STD declval<_Rty1>(),
				_STD declval<_Rty2>()))))>());
	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<void>(0)) type;
	};

template<class _Ty1,
	class _Ty2>
	struct is_swappable_with
		: _Is_swappable_with<!is_void<_Ty1>::value && !is_void<_Ty2>::value
			&& !is_const<_Ty1>::value && !is_const<_Ty2>::value,
			_Ty1, _Ty2>::type
	{	// determine whether _Ty& is swappable with itself
	};

	// TEMPLATE CLASS is_nothrow_swappable_with
template<bool,
	class _Ty1,
	class _Ty2>
	struct _Is_nothrow_swappable_with
		: false_type
	{	// invalid swap expressiom
	};

template<class _Ty1,
	class _Ty2>
	struct _Is_nothrow_swappable_with<true, _Ty1, _Ty2>
	{	// tests whether _Ty1 is nothrow swappable with _Ty2
	typedef typename add_lvalue_reference<_Ty1>::type _Rty1;
	typedef typename add_lvalue_reference<_Ty2>::type _Rty2;

	template<class _Uty>
		static auto _Fn(int)
			-> decltype(_Cat_base<(_NOEXCEPT_OP(_NOEXCEPT_OP(
				_STD swap(_STD declval<_Rty1>(),
				_STD declval<_Rty2>()))))>());
	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<void>(0)) type;
	};

template<class _Ty1,
	class _Ty2>
	struct is_nothrow_swappable_with
		: _Is_nothrow_swappable_with<
			!is_void<_Ty1>::value && !is_void<_Ty2>::value
				&& !is_const<_Ty1>::value && !is_const<_Ty2>::value,
				_Ty1, _Ty2>::type
	{	// determine whether _Ty& is nothrow swappable with itself
	};

	// TEMPLATE CLASS is_swappable
template<bool,
	class _Ty>
	struct _Is_swappable
		: false_type
	{	// invalid swap expressiom
	};

template<class _Ty>
	struct _Is_swappable<true, _Ty>
	{	// tests whether _Ty& is swappable with itself
	typedef typename add_lvalue_reference<_Ty>::type _Rty;

	template<class _Uty>
		static auto _Fn(int)
			-> decltype(_Cat_base<(_NOEXCEPT_OP(_NOEXCEPT_OP(
				_STD swap(_STD declval<_Rty>(),
				_STD declval<_Rty>()))))>());
	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<void>(0)) type;
	};

template<class _Ty>
	struct is_swappable
		: _Is_swappable<!is_void<_Ty>::value
			&& !is_const<_Ty>::value, _Ty>::type
	{	// determine whether _Ty& is swappable with itself
	};

	// TEMPLATE CLASS is_final
template<class _Ty>
	struct is_final
		_IS_FINAL(_Ty)
	{	// determine whether _Ty is a final class
	};

	// TEMPLATE CLASS is_aggregate

 #if defined(_IS_AGGREGATE)
template<class _Ty>
	struct is_aggregate
		_IS_AGGREGATE(typename remove_cv<_Ty>::type)
	{	// determine whether _Ty is an aggregate class
	};

 #else /* defined(_IS_AGGREGATE) */
template<class _Ty>
	struct is_aggregate
		: false_type	// APPROXIMATION
	{	// determine whether _Ty is an aggregate class
	};
 #endif /* defined(_IS_AGGREGATE) */

	// TEMPLATE CLASS is_nothrow_swappable -- from C++17
template<class _Ty>
	struct is_nothrow_swappable
		: is_nothrow_swappable_with<_Ty, _Ty>::type
	{	// xxxinvalid swap expressiom
	};

 #if _HAS_TEMPLATE_ALIAS
		// ALIAS TEMPLATES
template<class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;

template<class _Ty>
	using remove_volatile_t = typename remove_volatile<_Ty>::type;

template<class _Ty>
	using remove_cv_t = typename remove_cv<_Ty>::type;

template<class _Ty>
	using add_const_t = typename add_const<_Ty>::type;

template<class _Ty>
	using add_volatile_t = typename add_volatile<_Ty>::type;

template<class _Ty>
	using add_cv_t = typename add_cv<_Ty>::type;

//template<class _Ty>
//	using remove_reference_t = typename remove_reference<_Ty>::type;

template<class _Ty>
	using add_lvalue_reference_t = typename add_lvalue_reference<_Ty>::type;

template<class _Ty>
	using add_rvalue_reference_t = typename add_rvalue_reference<_Ty>::type;

template<class _Ty>
	using make_signed_t = typename make_signed<_Ty>::type;

template<class _Ty>
	using make_unsigned_t = typename make_unsigned<_Ty>::type;

template<class _Ty>
	using remove_extent_t = typename remove_extent<_Ty>::type;

template<class _Ty>
	using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

template<class _Ty>
	using remove_pointer_t = typename remove_pointer<_Ty>::type;

template<class _Ty>
	using add_pointer_t = typename add_pointer<_Ty>::type;

template<size_t _Len,
	size_t _Align =
		_Len < alignment_of<short>::value
			? alignment_of<char>::value
		: _Len < alignment_of<int>::value
			? alignment_of<short>::value
		: _Len < alignment_of<double>::value
			? alignment_of<int>::value
		: _Len < alignment_of<max_align_t>::value
			? alignment_of<double>::value
		: alignment_of<max_align_t>::value>
	using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template<size_t _Len,
	class... _Types>
	using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

//template<bool _Test,
//	class _Ty = void>
//	using enable_if_t = typename enable_if<_Test, _Ty>::type;

template<bool _Test,
	class _Ty1,
	class _Ty2>
	using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

template<class... _Ty>
	using common_type_t = typename common_type<_Ty...>::type;

template<class _Ty>
	using underlying_type_t = typename underlying_type<_Ty>::type;

template<class _Func,
	class... _Types>
	using invoke_result_t = typename invoke_result<_Func, _Types...>::type;

template<class _Ty>
	using result_of_t = typename result_of<_Ty>::type;
 #endif /* _HAS_TEMPLATE_ALIAS */

 #if _HAS_VARIABLE_TEMPLATES
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool has_unique_object_representations_v =
		has_unique_object_representations<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_void_v =
		is_void<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_null_pointer_v =
		is_null_pointer<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_integral_v =
		is_integral<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_floating_point_v =
		is_floating_point<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_array_v =
		is_array<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_pointer_v =
		is_pointer<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_lvalue_reference_v =
		is_lvalue_reference<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_rvalue_reference_v =
		is_rvalue_reference<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_member_object_pointer_v =
		is_member_object_pointer<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_member_function_pointer_v =
		is_member_function_pointer<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_enum_v =
		is_enum<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_union_v =
		is_union<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_class_v =
		is_class<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_function_v =
		is_function<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_reference_v =
		is_reference<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_arithmetic_v =
		is_arithmetic<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_fundamental_v =
		is_fundamental<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_object_v =
		is_object<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_scalar_v =
		is_scalar<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_compound_v =
		is_compound<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_member_pointer_v =
		is_member_pointer<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_const_v =
		is_const<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_volatile_v =
		is_volatile<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_trivial_v =
		is_trivial<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_trivially_copyable_v =
		is_trivially_copyable<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_standard_layout_v =
		is_standard_layout<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_pod_v =
		is_pod<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_literal_type_v =
		is_literal_type<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_empty_v =
		is_empty<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_polymorphic_v =
		is_polymorphic<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_abstract_v =
		is_abstract<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_final_v =
		is_final<_Ty>::value;

template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_aggregate_v =
		is_aggregate<_Ty>::value;

template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_signed_v =
		is_signed<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_unsigned_v =
		is_unsigned<_Ty>::value;
template<class _Ty,
	class... _Args>
	_INLINE_VAR _CONST_DATA bool is_constructible_v =
		is_constructible<_Ty, _Args...>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_default_constructible_v =
		is_default_constructible<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_copy_constructible_v =
		is_copy_constructible<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_move_constructible_v =
		is_move_constructible<_Ty>::value;
template<class _To,
	class _From>
	_INLINE_VAR _CONST_DATA bool is_assignable_v =
		is_assignable<_To, _From>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_copy_assignable_v =
		is_copy_assignable<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_move_assignable_v =
		is_move_assignable<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_destructible_v =
		is_destructible<_Ty>::value;
template<class _Ty,
	class... _Types>
	_INLINE_VAR _CONST_DATA bool is_trivially_constructible_v =
		is_trivially_constructible<_Ty, _Types...>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_trivially_default_constructible_v =
		is_trivially_default_constructible<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_trivially_copy_constructible_v =
		is_trivially_copy_constructible<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_trivially_move_constructible_v =
		is_trivially_move_constructible<_Ty>::value;
template<class _To,
	class _From>
	_INLINE_VAR _CONST_DATA bool is_trivially_assignable_v =
		is_trivially_assignable<_To, _From>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_trivially_copy_assignable_v =
		is_trivially_copy_assignable<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_trivially_move_assignable_v =
		is_trivially_move_assignable<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_trivially_destructible_v =
		is_trivially_destructible<_Ty>::value;
template<class _Ty,
	class... _Types>
	_INLINE_VAR _CONST_DATA bool is_nothrow_constructible_v =
		is_nothrow_constructible<_Ty, _Types...>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_nothrow_default_constructible_v =
		is_nothrow_default_constructible<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_nothrow_copy_constructible_v =
		is_nothrow_copy_constructible<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_nothrow_move_constructible_v =
		is_nothrow_move_constructible<_Ty>::value;
template<class _To,
	class _From>
	_INLINE_VAR _CONST_DATA bool is_nothrow_assignable_v =
		is_nothrow_assignable<_To, _From>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_nothrow_copy_assignable_v =
		is_nothrow_copy_assignable<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_nothrow_move_assignable_v =
		is_nothrow_move_assignable<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_nothrow_destructible_v =
		is_nothrow_destructible<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool has_virtual_destructor_v =
		has_virtual_destructor<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA size_t alignment_of_v =
		alignment_of<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA size_t rank_v =
		rank<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA size_t extent_v =
		extent<_Ty>::value;
template<class _Ty1,
	class _Ty2>
	_INLINE_VAR _CONST_DATA bool is_same_v =
		is_same<_Ty1, _Ty2>::value;
template<class _Base,
	class _Der>
	_INLINE_VAR _CONST_DATA bool is_base_of_v =
		is_base_of<_Base, _Der>::value;
template<class _From,
	class _To>
	_INLINE_VAR _CONST_DATA bool is_convertible_v =
		is_convertible<_From, _To>::value;
template<class _Func,
	class _Ret>
	_INLINE_VAR _CONST_DATA bool is_callable_v =
		is_callable<_Func, _Ret>::value;
template<class _Func,
	class _Ret>
	_INLINE_VAR _CONST_DATA bool is_nothrow_callable_v =
		is_nothrow_callable<_Func, _Ret>::value;

template<class _Func,
	class... _Types>
	_INLINE_VAR _CONST_DATA bool is_invocable_v =
		is_invocable<_Func, _Types...>::value;

template<class _Ret,
	class _Func,
	class... _Types>
	_INLINE_VAR _CONST_DATA bool is_invocable_r_v =
		is_invocable<_Func, _Types...>::value;

template<class _Func,
	class... _Types>
	_INLINE_VAR _CONST_DATA bool is_nothrow_invocable_v =
		is_nothrow_invocable<_Func, _Types...>::value;

template<class _Ret,
	class _Func,
	class... _Types>
	_INLINE_VAR _CONST_DATA bool is_nothrow_invocable_r_v =
		is_nothrow_invocable<_Func, _Types...>::value;

template<class _Ty1,
	class _Ty2>
	_INLINE_VAR _CONST_DATA bool is_swappable_with_v =
		is_swappable_with<_Ty1, _Ty2>::value;
template<class _Ty1,
	class _Ty2>
	_INLINE_VAR _CONST_DATA bool is_nothrow_swappable_with_v =
		is_nothrow_swappable_with<_Ty1, _Ty2>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_swappable_v =
		is_swappable<_Ty>::value;
template<class _Ty>
	_INLINE_VAR _CONST_DATA bool is_nothrow_swappable_v =
		is_nothrow_swappable<_Ty>::value;

template<class... _Base>
	_INLINE_VAR _CONST_DATA bool conjunction_v =
		conjunction<_Base...>::value;
template<class... _Base>
	_INLINE_VAR _CONST_DATA bool disjunction_v =
		disjunction<_Base...>::value;
template<class _Base>
	_INLINE_VAR _CONST_DATA bool negation_v =
		negation<_Base>::value;
 #endif /* _HAS_VARIABLE_TEMPLATES */
_STD_END
#endif /* _TYPE_TRAITS_ */

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
 * V8.05/17:1422 +invoke */
